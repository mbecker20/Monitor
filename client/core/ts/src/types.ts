/*
 Generated by typeshare 1.9.2
*/

/** JSON containing an authentication token. */
export interface JwtResponse {
	/** A token the user can use to authenticate their requests. */
	jwt: string;
}

/** Response for [CreateLocalUser]. */
export type CreateLocalUserResponse = JwtResponse;

/** The response for [LoginLocalUser] */
export type LoginLocalUserResponse = JwtResponse;

/** Response for [ExchangeForJwt]. */
export type ExchangeForJwtResponse = JwtResponse;

export interface MongoIdObj {
	$oid: string;
}

export type MongoId = MongoIdObj;

export type UserConfig = 
	/** User that logs in with username / password */
	| { type: "Local", data: {
	password: string;
}}
	/** User that logs in via Google Oauth */
	| { type: "Google", data: {
	google_id: string;
	avatar: string;
}}
	/** User that logs in via Github Oauth */
	| { type: "Github", data: {
	github_id: string;
	avatar: string;
}}
	/** Non-human managed user, can have it's own permissions / api keys */
	| { type: "Service", data: {
	description: string;
}};

export type I64 = number;

/** The levels of permission that a User or UserGroup can have on a resource. */
export enum PermissionLevel {
	/** No permissions. */
	None = "None",
	/** Can see the rousource */
	Read = "Read",
	/** Can execute actions on the resource */
	Execute = "Execute",
	/** Can update the resource configuration */
	Write = "Write",
}

export interface User {
	/**
	 * The Mongo ID of the User.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized User) }`
	 */
	_id?: MongoId;
	/** The globally unique username for the user. */
	username: string;
	/** Whether user is enabled / able to access the api. */
	enabled?: boolean;
	/** Whether the user has global admin permissions. */
	admin?: boolean;
	/** Whether the user has permission to create servers. */
	create_server_permissions?: boolean;
	/** Whether the user has permission to create builds */
	create_build_permissions?: boolean;
	/** The user-type specific config. */
	config: UserConfig;
	/** When the user last opened updates dropdown. */
	last_update_view?: I64;
	/** Recently viewed ids */
	recents?: Record<ResourceTarget["type"], string[]>;
	/** Give the user elevated permissions on all resources of a certain type */
	all?: Record<ResourceTarget["type"], PermissionLevel>;
	updated_at?: I64;
}

export type GetUserResponse = User;

/** Represents an empty json object: `{}` */
export interface NoData {
}

export type CancelBuildResponse = NoData;

/** Severity level of problem. */
export enum SeverityLevel {
	/** No problem. */
	Ok = "OK",
	/** Problem is imminent. */
	Warning = "WARNING",
	/** Problem fully realized. */
	Critical = "CRITICAL",
}

/** Used to reference a specific resource across all resource types */
export type ResourceTarget = 
	| { type: "System", id: string }
	| { type: "Build", id: string }
	| { type: "Builder", id: string }
	| { type: "Deployment", id: string }
	| { type: "Server", id: string }
	| { type: "Repo", id: string }
	| { type: "Alerter", id: string }
	| { type: "Procedure", id: string }
	| { type: "ServerTemplate", id: string }
	| { type: "ResourceSync", id: string };

/** The variants of data related to the alert. */
export type AlertData = 
	/** A null alert */
	| { type: "None", data: {
}}
	/** A server could not be reached. */
	| { type: "ServerUnreachable", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The error data */
	err?: _Serror;
}}
	/** A server has high CPU usage. */
	| { type: "ServerCpu", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The cpu usage percentage */
	percentage: number;
}}
	/** A server has high memory usage. */
	| { type: "ServerMem", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The used memory */
	used_gb: number;
	/** The total memory */
	total_gb: number;
}}
	/** A server has high disk usage. */
	| { type: "ServerDisk", data: {
	/** The id of the server */
	id: string;
	/** The name of the server */
	name: string;
	/** The region of the server */
	region?: string;
	/** The mount path of the disk */
	path: string;
	/** The used portion of the disk in GB */
	used_gb: number;
	/** The total size of the disk in GB */
	total_gb: number;
}}
	/** A container's state has changed unexpectedly. */
	| { type: "ContainerStateChange", data: {
	/** The id of the deployment */
	id: string;
	/** The name of the deployment */
	name: string;
	/** The server id of server deployment is on */
	server_id: string;
	/** The server name */
	server_name: string;
	/** The previous container state */
	from: DeploymentState;
	/** The current container state */
	to: DeploymentState;
}}
	/** An AWS builder failed to terminate. */
	| { type: "AwsBuilderTerminationFailed", data: {
	/** The id of the aws instance which failed to terminate */
	instance_id: string;
	/** A reason for the failure */
	message: string;
}}
	/** A resource sync has pending updates */
	| { type: "ResourceSyncPendingUpdates", data: {
	/** The id of the resource sync */
	id: string;
	/** The name of the resource sync */
	name: string;
}}
	/** A build has failed */
	| { type: "BuildFailed", data: {
	/** The id of the build */
	id: string;
	/** The name of the build */
	name: string;
	/** The version that failed to build */
	version: Version;
}};

/** Representation of an alert in the system. */
export interface Alert {
	/**
	 * The Mongo ID of the alert.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Alert) }`
	 */
	_id?: MongoId;
	/** Unix timestamp in milliseconds the alert was opened */
	ts: I64;
	/** Whether the alert is already resolved */
	resolved: boolean;
	/** The severity of the alert */
	level: SeverityLevel;
	/** The target of the alert */
	target: ResourceTarget;
	/** The data attached to the alert */
	data: AlertData;
	/** The timestamp of alert resolution */
	resolved_ts?: I64;
}

export type GetAlertResponse = Alert;

export interface Resource<Config, Info> {
	/**
	 * The Mongo ID of the resource.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Resource<T>) }`
	 */
	_id?: MongoId;
	/**
	 * The resource name.
	 * This is guaranteed unique among others of the same resource type.
	 */
	name: string;
	/** A description for the resource */
	description?: string;
	/** When description last updated */
	updated_at?: I64;
	/** Tag Ids */
	tags?: string[];
	/** Resource-specific information (not user configurable). */
	info?: Info;
	/** Resource-specific configuration. */
	config?: Config;
}

export type AlerterEndpoint = 
	/** Send alert serialized to JSON to an http endpoint. */
	| { type: "Custom", params: CustomAlerterEndpoint }
	/** Send alert to a slack app */
	| { type: "Slack", params: SlackAlerterEndpoint };

export interface AlerterConfig {
	/** Whether the alerter is enabled */
	enabled: boolean;
	/**
	 * Where to route the alert messages.
	 * 
	 * Default: Custom endpoint `http://localhost:7000`
	 */
	endpoint?: AlerterEndpoint;
	/**
	 * Only send specific alert types.
	 * If empty, will send all alert types.
	 */
	alert_types?: AlertData["type"][];
	/**
	 * Only send alerts on specific resources.
	 * If empty, will send alerts for all resources.
	 */
	resources?: ResourceTarget[];
	/** DON'T send alerts on these resources. */
	except_resources?: ResourceTarget[];
}

export type Alerter = Resource<AlerterConfig, undefined>;

export type GetAlerterResponse = Alerter;

export interface ResourceListItem<Info> {
	/** The resource id */
	id: string;
	/** The resource type, ie `Server` or `Deployment` */
	type: ResourceTarget["type"];
	/** The resource name */
	name: string;
	/** Tag Ids */
	tags: string[];
	/** Resource specific info */
	info: Info;
}

export interface AlerterListItemInfo {
	/** Whether alerter is enabled for sending alerts */
	enabled: boolean;
	/** The type of the alerter, eg. `Slack`, `Custom` */
	endpoint_type: AlerterEndpoint["type"];
}

export type AlerterListItem = ResourceListItem<AlerterListItemInfo>;

export type ListAlertersResponse = AlerterListItem[];

export type ListFullAlertersResponse = Alerter[];

export interface Version {
	major: number;
	minor: number;
	patch: number;
}

export interface SystemCommand {
	path?: string;
	command?: string;
}

/** Configuration for the registry to push the built image to. */
export type ImageRegistry = 
	/** Don't push the image to any registry */
	| { type: "None", params: NoData }
	/** Push the image to DockerHub */
	| { type: "DockerHub", params: CloudRegistryConfig }
	/**
	 * Push the image to the Github Container Registry.
	 * 
	 * See [the Github docs](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#pushing-container-images)
	 * for information on creating an access token
	 */
	| { type: "Ghcr", params: CloudRegistryConfig }
	/**
	 * Push the image to Aws Elastic Container Registry
	 * 
	 * The string held in 'params' should match a label of an `aws_ecr_registry` in the core config.
	 */
	| { type: "AwsEcr", params: string }
	/** Todo. Will point to a custom "Registry" resource by id */
	| { type: "Custom", params: string };

export interface EnvironmentVar {
	variable: string;
	value: string;
}

/** The build configuration. */
export interface BuildConfig {
	/** Which builder is used to build the image. */
	builder_id?: string;
	/** The current version of the build. */
	version?: Version;
	/** The Github repo used as the source of the build. */
	repo?: string;
	/** The branch of the repo. */
	branch: string;
	/** Optionally set a specific commit hash. */
	commit?: string;
	/**
	 * The github account used to clone (used to access private repos).
	 * Empty string is public clone (only public repos).
	 */
	github_account?: string;
	/** The optional command run after repo clone and before docker build. */
	pre_build?: SystemCommand;
	/** Configuration for the registry to push the built image to. */
	image_registry?: ImageRegistry;
	/**
	 * The path of the docker build context relative to the root of the repo.
	 * Default: "." (the root of the repo).
	 */
	build_path: string;
	/** The path of the dockerfile relative to the build path. */
	dockerfile_path: string;
	/** Whether to skip secret interpolation in the build_args. */
	skip_secret_interp?: boolean;
	/** Whether to use buildx to build (eg `docker buildx build ...`) */
	use_buildx?: boolean;
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
	/** Any extra docker cli arguments to be included in the build command */
	extra_args?: string[];
	/**
	 * Docker build arguments.
	 * 
	 * These values are visible in the final image by running `docker inspect`.
	 */
	build_args?: EnvironmentVar[] | string;
	/**
	 * Secret arguments.
	 * 
	 * These values remain hidden in the final image by using
	 * docker secret mounts. See `<https://docs.docker.com/build/building/secrets>`.
	 * 
	 * The values can be used in RUN commands:
	 * ```
	 * RUN --mount=type=secret,id=SECRET_KEY \
	 * SECRET_KEY=$(cat /run/secrets/SECRET_KEY) ...
	 * ```
	 */
	secret_args?: EnvironmentVar[] | string;
	/** Docker labels */
	labels?: EnvironmentVar[] | string;
}

export interface BuildInfo {
	last_built_at: I64;
}

export type Build = Resource<BuildConfig, BuildInfo>;

export type GetBuildResponse = Build;

export enum BuildState {
	/** Last build successful (or never built) */
	Ok = "Ok",
	/** Last build failed */
	Failed = "Failed",
	/** Currently building */
	Building = "Building",
	/** Other case */
	Unknown = "Unknown",
}

export interface BuildListItemInfo {
	/** Unix timestamp in milliseconds of last build */
	last_built_at: I64;
	/** The current version of the build */
	version: Version;
	/** The Github repo used as the source of the build */
	repo: string;
	/** The branch of the repo */
	branch: string;
	/** State of the build. Reflects whether most recent build successful. */
	state: BuildState;
}

export type BuildListItem = ResourceListItem<BuildListItemInfo>;

export type ListBuildsResponse = BuildListItem[];

export type ListFullBuildsResponse = Build[];

export interface BuildActionState {
	building: boolean;
}

export type GetBuildActionStateResponse = BuildActionState;

export interface BuildVersionResponseItem {
	version: Version;
	ts: I64;
}

export type GetBuildVersionsResponse = BuildVersionResponseItem[];

export type ListGithubOrganizationsResponse = string[];

export type ListDockerOrganizationsResponse = string[];

export type ListCommonBuildExtraArgsResponse = string[];

export type BuilderConfig = 
	/** Use a connected server an image builder. */
	| { type: "Server", params: ServerBuilderConfig }
	/** Use EC2 instances spawned on demand as an image builder. */
	| { type: "Aws", params: AwsBuilderConfig };

export type Builder = Resource<BuilderConfig, undefined>;

export type GetBuilderResponse = Builder;

export interface BuilderListItemInfo {
	builder_type: string;
	instance_type?: string;
}

export type BuilderListItem = ResourceListItem<BuilderListItemInfo>;

export type ListBuildersResponse = BuilderListItem[];

export type ListFullBuildersResponse = Builder[];

export type DeploymentImage = 
	/** Deploy any external image. */
	| { type: "Image", params: {
	/** The docker image, can be from any registry that works with docker and that the host server can reach. */
	image?: string;
}}
	/** Deploy a monitor build. */
	| { type: "Build", params: {
	/** The id of the build */
	build_id?: string;
	/**
	 * Use a custom / older version of the image produced by the build.
	 * if version is 0.0.0, this means `latest` image.
	 */
	version?: Version;
}};

export enum RestartMode {
	NoRestart = "no",
	OnFailure = "on-failure",
	Always = "always",
	UnlessStopped = "unless-stopped",
}

export enum TerminationSignal {
	SigHup = "SIGHUP",
	SigInt = "SIGINT",
	SigQuit = "SIGQUIT",
	SigTerm = "SIGTERM",
}

export interface TerminationSignalLabel {
	signal: TerminationSignal;
	label: string;
}

export interface Conversion {
	/** reference on the server. */
	local: string;
	/** reference in the container. */
	container: string;
}

export interface DeploymentConfig {
	/** The id of server the deployment is deployed on. */
	server_id?: string;
	/**
	 * The image which the deployment deploys.
	 * Can either be a user inputted image, or a Monitor build.
	 */
	image?: DeploymentImage;
	/**
	 * Configure the registry used to pull the image from the registry.
	 * Used with `docker login`.
	 * 
	 * When using attached build as image source:
	 * - If the field is `None` variant, will use the same ImageRegistry config as the build.
	 * - Otherwise, it must match the variant of the ImageRegistry build config.
	 * - Only the account is used, the organization is not needed here
	 */
	image_registry?: ImageRegistry;
	/** Whether to skip secret interpolation into the deployment environment variables. */
	skip_secret_interp?: boolean;
	/** Whether to redeploy the deployment whenever the attached build finishes. */
	redeploy_on_build?: boolean;
	/** Whether to send ContainerStateChange alerts for this deployment. */
	send_alerts: boolean;
	/**
	 * The network attached to the container.
	 * Default is `host`.
	 */
	network: string;
	/** The restart mode given to the container. */
	restart?: RestartMode;
	/**
	 * This is interpolated at the end of the `docker run` command,
	 * which means they are either passed to the containers inner process,
	 * or replaces the container command, depending on use of ENTRYPOINT or CMD in dockerfile.
	 * Empty is no command.
	 */
	command?: string;
	/** The default termination signal to use to stop the deployment. Defaults to SigTerm (default docker signal). */
	termination_signal?: TerminationSignal;
	/** The termination timeout. */
	termination_timeout: number;
	/**
	 * Extra args which are interpolated into the `docker run` command,
	 * and affect the container configuration.
	 */
	extra_args?: string[];
	/**
	 * Labels attached to various termination signal options.
	 * Used to specify different shutdown functionality depending on the termination signal.
	 */
	term_signal_labels: TerminationSignalLabel[];
	/**
	 * The container port mapping.
	 * Irrelevant if container network is `host`.
	 * Maps ports on host to ports on container.
	 */
	ports?: Conversion[];
	/**
	 * The container volume mapping.
	 * Maps files / folders on host to files / folders in container.
	 */
	volumes?: Conversion[];
	/** The environment variables passed to the container. */
	environment?: EnvironmentVar[] | string;
	/** The docker labels given to the container. */
	labels?: EnvironmentVar[] | string;
}

export type Deployment = Resource<DeploymentConfig, undefined>;

export type GetDeploymentResponse = Deployment;

/**
 * Variants de/serialized from/to snake_case.
 * 
 * Eg.
 * - NotDeployed -> not_deployed
 * - Restarting -> restarting
 * - Running -> running.
 */
export enum DeploymentState {
	Unknown = "unknown",
	NotDeployed = "not_deployed",
	Created = "created",
	Restarting = "restarting",
	Running = "running",
	Removing = "removing",
	Paused = "paused",
	Exited = "exited",
	Dead = "dead",
}

export interface DeploymentListItemInfo {
	/** The state of the deployment / underlying docker container. */
	state: DeploymentState;
	/** The status of the docker container (eg. up 12 hours, exited 5 minutes ago.) */
	status?: string;
	/** The image attached to the deployment. */
	image: string;
	/** The server that deployment sits on. */
	server_id: string;
	/** An attached monitor build, if it exists. */
	build_id?: string;
}

export type DeploymentListItem = ResourceListItem<DeploymentListItemInfo>;

export type ListDeploymentsResponse = DeploymentListItem[];

export type ListFullDeploymentsResponse = Deployment[];

/** Represents the output of some command being run */
export interface Log {
	/** A label for the log */
	stage: string;
	/** The command which was executed */
	command: string;
	/** The output of the command in the standard channel */
	stdout: string;
	/** The output of the command in the error channel */
	stderr: string;
	/** Whether the command run was successful */
	success: boolean;
	/** The start time of the command execution */
	start_ts: I64;
	/** The end time of the command execution */
	end_ts: I64;
}

export type GetLogResponse = Log;

export type SearchLogResponse = Log;

export interface DockerContainerStats {
	name: string;
	cpu_perc: string;
	mem_perc: string;
	mem_usage: string;
	net_io: string;
	block_io: string;
	pids: string;
}

export type GetDeploymentStatsResponse = DockerContainerStats;

export interface DeploymentActionState {
	deploying: boolean;
	stopping: boolean;
	starting: boolean;
	removing: boolean;
	renaming: boolean;
}

export type GetDeploymentActionStateResponse = DeploymentActionState;

export type ListCommonDeploymentExtraArgsResponse = string[];

export type GetAvailableAwsEcrLabelsResponse = string[];

export type UserTarget = 
	/** User Id */
	| { type: "User", id: string }
	/** UserGroup Id */
	| { type: "UserGroup", id: string };

/** Representation of a User or UserGroups permission on a resource. */
export interface Permission {
	/** The id of the permission document */
	_id?: MongoId;
	/** The target User / UserGroup */
	user_target: UserTarget;
	/** The target resource */
	resource_target: ResourceTarget;
	/** The permission level */
	level?: PermissionLevel;
}

export type ListPermissionsResponse = Permission[];

export type GetPermissionLevelResponse = PermissionLevel;

export type ListUserTargetPermissionsResponse = Permission[];

/** A wrapper for all monitor exections. */
export type Execution = 
	/** The "null" execution. Does nothing. */
	| { type: "None", params: NoData }
	| { type: "RunProcedure", params: RunProcedure }
	| { type: "RunBuild", params: RunBuild }
	| { type: "Deploy", params: Deploy }
	| { type: "StartContainer", params: StartContainer }
	| { type: "StopContainer", params: StopContainer }
	| { type: "StopAllContainers", params: StopAllContainers }
	| { type: "RemoveContainer", params: RemoveContainer }
	| { type: "CloneRepo", params: CloneRepo }
	| { type: "PullRepo", params: PullRepo }
	| { type: "PruneNetworks", params: PruneNetworks }
	| { type: "PruneImages", params: PruneImages }
	| { type: "PruneContainers", params: PruneContainers }
	| { type: "RunSync", params: RunSync }
	| { type: "Sleep", params: Sleep };

/** Allows to enable / disabled procedures in the sequence / parallel vec on the fly */
export interface EnabledExecution {
	/** The execution request to run. */
	execution: Execution;
	/** Whether the execution is enabled to run in the procedure. */
	enabled: boolean;
}

/** A single stage of a procedure. Runs a list of executions in parallel. */
export interface ProcedureStage {
	/** A name for the procedure */
	name: string;
	/** Whether the stage should be run as part of the procedure. */
	enabled: boolean;
	/** The executions in the stage */
	executions?: EnabledExecution[];
}

/** Config for the [Procedure] */
export interface ProcedureConfig {
	/** The stages to be run by the procedure. */
	stages?: ProcedureStage[];
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

/**
 * Procedures run a series of stages sequentially, where
 * each stage runs executions in parallel.
 */
export type Procedure = Resource<ProcedureConfig, undefined>;

export type GetProcedureResponse = Procedure;

export enum ProcedureState {
	/** Last run successful */
	Ok = "Ok",
	/** Last run failed */
	Failed = "Failed",
	/** Currently running */
	Running = "Running",
	/** Other case (never run) */
	Unknown = "Unknown",
}

export interface ProcedureListItemInfo {
	/** Number of stages procedure has. */
	stages: I64;
	/** Reflect whether last run successful / currently running. */
	state: ProcedureState;
}

export type ProcedureListItem = ResourceListItem<ProcedureListItemInfo>;

export type ListProceduresResponse = ProcedureListItem[];

export type ListFullProceduresResponse = Procedure[];

export interface ProcedureActionState {
	running: boolean;
}

export type GetProcedureActionStateResponse = ProcedureActionState;

export interface RepoConfig {
	/** The server to clone the repo on. */
	server_id?: string;
	/** The github repo to clone. */
	repo?: string;
	/** The repo branch. */
	branch: string;
	/** Optionally set a specific commit hash. */
	commit?: string;
	/**
	 * The github account to use to clone.
	 * It must be available in the server's periphery config.
	 */
	github_account?: string;
	/** Explicitly specificy the folder to clone the repo in. */
	path?: string;
	/**
	 * Command to be run after the repo is cloned.
	 * The path is relative to the root of the repo.
	 */
	on_clone?: SystemCommand;
	/**
	 * Command to be run after the repo is pulled.
	 * The path is relative to the root of the repo.
	 */
	on_pull?: SystemCommand;
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

export interface RepoInfo {
	/** When repo was last pulled */
	last_pulled_at: I64;
}

export type Repo = Resource<RepoConfig, RepoInfo>;

export type GetRepoResponse = Repo;

export enum RepoState {
	/** Unknown case */
	Unknown = "Unknown",
	/** Last clone / pull successful (or never cloned) */
	Ok = "Ok",
	/** Last clone / pull failed */
	Failed = "Failed",
	/** Currently cloning */
	Cloning = "Cloning",
	/** Currently pullling */
	Pulling = "Pulling",
}

export interface RepoListItemInfo {
	/** The server that repo sits on. */
	server_id: string;
	/** Repo last cloned / pulled timestamp in ms. */
	last_pulled_at: I64;
	/** The configured github repo */
	repo: string;
	/** The configured branch */
	branch: string;
	/** The repo state */
	state: RepoState;
	/** If the repo is cloned, will be the latest short commit hash. */
	latest_hash?: string;
	/** If the repo is cloned, will be the latest commit message. */
	latest_message?: string;
}

export type RepoListItem = ResourceListItem<RepoListItemInfo>;

export type ListReposResponse = RepoListItem[];

export type ListFullReposResponse = Repo[];

export interface RepoActionState {
	/** Whether repo currently cloning */
	cloning: boolean;
	/** Whether repo currently pulling */
	pulling: boolean;
}

export type GetRepoActionStateResponse = RepoActionState;

/** Server configuration. */
export interface ServerConfig {
	/**
	 * The http address of the periphery client.
	 * Example: http://localhost:8120
	 */
	address: string;
	/** An optional region label */
	region?: string;
	/**
	 * Whether a server is enabled.
	 * If a server is disabled,
	 * you won't be able to perform any actions on it or see deployment's status.
	 * default: true
	 */
	enabled: boolean;
	/**
	 * Whether to monitor any server stats beyond passing health check.
	 * default: true
	 */
	stats_monitoring: boolean;
	/**
	 * Whether to trigger 'docker image prune -a -f' every 24 hours.
	 * default: true
	 */
	auto_prune: boolean;
	/** Whether to send alerts about the servers reachability */
	send_unreachable_alerts: boolean;
	/** Whether to send alerts about the servers CPU status */
	send_cpu_alerts: boolean;
	/** Whether to send alerts about the servers MEM status */
	send_mem_alerts: boolean;
	/** Whether to send alerts about the servers DISK status */
	send_disk_alerts: boolean;
	/** The percentage threshhold which triggers WARNING state for CPU. */
	cpu_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for CPU. */
	cpu_critical: number;
	/** The percentage threshhold which triggers WARNING state for MEM. */
	mem_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for MEM. */
	mem_critical: number;
	/** The percentage threshhold which triggers WARNING state for DISK. */
	disk_warning: number;
	/** The percentage threshhold which triggers CRITICAL state for DISK. */
	disk_critical: number;
}

export type Server = Resource<ServerConfig, undefined>;

export type GetServerResponse = Server;

export enum ServerState {
	/** Server is unreachable. */
	NotOk = "NotOk",
	/** Server health check passing. */
	Ok = "Ok",
	/** Server is disabled. */
	Disabled = "Disabled",
}

export interface ServerListItemInfo {
	/** The server's state. */
	state: ServerState;
	/** Region of the server. */
	region: string;
	/** Whether server is configured to send unreachable alerts. */
	send_unreachable_alerts: boolean;
	/** Whether server is configured to send cpu alerts. */
	send_cpu_alerts: boolean;
	/** Whether server is configured to send mem alerts. */
	send_mem_alerts: boolean;
	/** Whether server is configured to send disk alerts. */
	send_disk_alerts: boolean;
}

export type ServerListItem = ResourceListItem<ServerListItemInfo>;

export type ListServersResponse = ServerListItem[];

export type ListFullServersResponse = Server[];

/** Current pending actions on the server. */
export interface ServerActionState {
	/** Server currently pruning networks */
	pruning_networks: boolean;
	/** Server currently pruning containers */
	pruning_containers: boolean;
	/** Server currently pruning images */
	pruning_images: boolean;
	/** Server currently stopping all containers. */
	stopping_containers: boolean;
}

export type GetServerActionStateResponse = ServerActionState;

/** Ipam Configuration. */
export interface IpamConfig {
	Subnet?: string;
	IPRange?: string;
	Gateway?: string;
	AuxiliaryAddresses?: Record<string, string>;
}

/** Ipam related information */
export interface Ipam {
	/** Name of the IPAM driver to use. */
	Driver?: string;
	/** List of IPAM configuration options, specified as a map:  ``` {\"Subnet\": <CIDR>, \"IPRange\": <CIDR>, \"Gateway\": <IP address>, \"AuxAddress\": <device_name:IP address>} ``` */
	Config?: IpamConfig[];
	/** Driver-specific options, specified as a map. */
	Options?: Record<string, string>;
}

/** A container on a network. */
export interface NetworkContainer {
	Name?: string;
	EndpointID?: string;
	MacAddress?: string;
	IPv4Address?: string;
	IPv6Address?: string;
}

/** Summary of a docker network on a server. */
export interface DockerNetwork {
	/** The name of the docker network */
	Name?: string;
	/** The Id of the docker network */
	Id?: string;
	/** Timestamp network created */
	Created?: string;
	Scope?: string;
	Driver?: string;
	EnableIPv6?: boolean;
	IPAM?: Ipam;
	Internal?: boolean;
	Attachable?: boolean;
	Ingress?: boolean;
	Containers?: Record<string, NetworkContainer>;
	Options?: Record<string, string>;
	Labels?: Record<string, string>;
}

export type GetDockerNetworksResponse = DockerNetwork[];

/** Summary of a docker image cached on a server */
export interface ImageSummary {
	/** ID is the content-addressable ID of an image.  This identifier is a content-addressable digest calculated from the image's configuration (which includes the digests of layers used by the image).  Note that this digest differs from the `RepoDigests` below, which holds digests of image manifests that reference the image. */
	Id: string;
	/** ID of the parent image.  Depending on how the image was created, this field may be empty and is only set for images that were built/created locally. This field is empty if the image was pulled from an image registry. */
	ParentId: string;
	/** List of image names/tags in the local image cache that reference this image.  Multiple image tags can refer to the same image, and this list may be empty if no tags reference the image, in which case the image is \"untagged\", in which case it can still be referenced by its ID. */
	RepoTags: string[];
	/** List of content-addressable digests of locally available image manifests that the image is referenced from. Multiple manifests can refer to the same image.  These digests are usually only available if the image was either pulled from a registry, or if the image was pushed to a registry, which is when the manifest is generated and its digest calculated. */
	RepoDigests: string[];
	/** Date and time at which the image was created as a Unix timestamp (number of seconds sinds EPOCH). */
	Created: I64;
	/** Total size of the image including all layers it is composed of. */
	Size: I64;
	/** Total size of image layers that are shared between this image and other images.  This size is not calculated by default. `-1` indicates that the value has not been set / calculated. */
	SharedSize: I64;
	/** Total size of the image including all layers it is composed of.  In versions of Docker before v1.10, this field was calculated from the image itself and all of its parent images. Docker v1.10 and up store images self-contained, and no longer use a parent-chain, making this field an equivalent of the Size field.  This field is kept for backward compatibility, but may be removed in a future version of the API. */
	VirtualSize?: I64;
	/** User-defined key/value metadata. */
	Labels: Record<string, string>;
	/** Number of containers using this image. Includes both stopped and running containers.  This size is not calculated by default, and depends on which API endpoint is used. `-1` indicates that the value has not been set / calculated. */
	Containers: I64;
}

export type GetDockerImagesResponse = ImageSummary[];

/** A summary of a docker container on a server. */
export interface ContainerSummary {
	/** Name of the container. */
	name: string;
	/** Id of the container. */
	id: string;
	/** The image the container is based on. */
	image: string;
	/** The docker labels on the container. */
	labels: Record<string, string>;
	/** The state of the container, like `running` or `not_deployed` */
	state: DeploymentState;
	/** The status string of the docker container. */
	status?: string;
}

export type GetDockerContainersResponse = ContainerSummary[];

/** System information of a server */
export interface SystemInformation {
	/** The system name */
	name?: string;
	/** The system long os version */
	os?: string;
	/** System's kernel version */
	kernel?: string;
	/** Physical core count */
	core_count?: number;
	/** System hostname based off DNS */
	host_name?: string;
	/** The CPU's brand */
	cpu_brand: string;
}

export type GetSystemInformationResponse = SystemInformation;

/** Info for a single disk mounted on the system. */
export interface SingleDiskUsage {
	/** The mount point of the disk */
	mount: string;
	/** Detected file system */
	file_system: string;
	/** Used portion of the disk in GB */
	used_gb: number;
	/** Total size of the disk in GB */
	total_gb: number;
}

export enum Timelength {
	OneSecond = "1-sec",
	FiveSeconds = "5-sec",
	TenSeconds = "10-sec",
	FifteenSeconds = "15-sec",
	ThirtySeconds = "30-sec",
	OneMinute = "1-min",
	TwoMinutes = "2-min",
	FiveMinutes = "5-min",
	TenMinutes = "10-min",
	FifteenMinutes = "15-min",
	ThirtyMinutes = "30-min",
	OneHour = "1-hr",
	TwoHours = "2-hr",
	SixHours = "6-hr",
	EightHours = "8-hr",
	TwelveHours = "12-hr",
	OneDay = "1-day",
	ThreeDay = "3-day",
	OneWeek = "1-wk",
	TwoWeeks = "2-wk",
	ThirtyDays = "30-day",
}

/** Realtime system stats data. */
export interface SystemStats {
	/** Cpu usage percentage */
	cpu_perc: number;
	/** Memory used in GB */
	mem_used_gb: number;
	/** Total memory in GB */
	mem_total_gb: number;
	/** Breakdown of individual disks, ie their usages, sizes, and mount points */
	disks: SingleDiskUsage[];
	/** The rate the system stats are being polled from the system */
	polling_rate: Timelength;
	/** Unix timestamp in milliseconds when stats were last polled */
	refresh_ts: I64;
	/** Unix timestamp in milliseconds when disk list was last refreshed */
	refresh_list_ts: I64;
}

export type GetSystemStatsResponse = SystemStats;

/** Information about a process on the system. */
export interface SystemProcess {
	/** The process PID */
	pid: number;
	/** The process name */
	name: string;
	/** The path to the process executable */
	exe?: string;
	/** The command used to start the process */
	cmd: string[];
	/** The time the process was started */
	start_time?: number;
	/**
	 * The cpu usage percentage of the process.
	 * This is in core-percentage, eg 100% is 1 full core, and
	 * an 8 core machine would max at 800%.
	 */
	cpu_perc: number;
	/** The memory usage of the process in MB */
	mem_mb: number;
	/** Process disk read in KB/s */
	disk_read_kb: number;
	/** Process disk write in KB/s */
	disk_write_kb: number;
}

export type GetSystemProcessesResponse = SystemProcess[];

export type GetAvailableSecretsResponse = string[];

export type ServerTemplateConfig = 
	/** Template to launch an AWS EC2 instance */
	| { type: "Aws", params: AwsServerTemplateConfig }
	/** Template to launch a Hetzner server */
	| { type: "Hetzner", params: HetznerServerTemplateConfig };

export type ServerTemplate = Resource<ServerTemplateConfig, undefined>;

export type GetServerTemplateResponse = ServerTemplate;

export interface ServerTemplateListItemInfo {
	/** The cloud provider */
	provider: string;
	/** The instance type, eg c5.2xlarge on for Aws templates */
	instance_type?: string;
}

export type ServerTemplateListItem = ResourceListItem<ServerTemplateListItemInfo>;

export type ListServerTemplatesResponse = ServerTemplateListItem[];

export type ListFullServerTemplatesResponse = ServerTemplate[];

/** The sync configuration. */
export interface ResourceSyncConfig {
	/** The Github repo used as the source of the build. */
	repo?: string;
	/** The branch of the repo. */
	branch: string;
	/** Optionally set a specific commit hash. */
	commit?: string;
	/**
	 * The github account used to clone (used to access private repos).
	 * Empty string is public clone (only public repos).
	 */
	github_account?: string;
	/**
	 * The github account used to clone (used to access private repos).
	 * Empty string is public clone (only public repos).
	 */
	resource_path: string;
	/**
	 * Whether sync should delete resources
	 * not declared in the resource files
	 */
	delete?: boolean;
	/** Whether incoming webhooks actually trigger action. */
	webhook_enabled: boolean;
}

export type PendingSyncUpdatesData = 
	| { type: "Ok", data: PendingSyncUpdatesDataOk }
	| { type: "Err", data: PendingSyncUpdatesDataErr };

export interface PendingSyncUpdates {
	/** The commit hash which produced these pending updates */
	hash?: string;
	/** The commit message which produced these pending updates */
	message?: string;
	/**
	 * The data associated with the sync. Either Ok containing diffs,
	 * or Err containing an error message
	 */
	data: PendingSyncUpdatesData;
}

export interface ResourceSyncInfo {
	/** Unix timestamp of last applied sync */
	last_sync_ts: I64;
	/** Short commit hash of last applied sync */
	last_sync_hash: string;
	/** Commit message of last applied sync */
	last_sync_message: string;
	/** Readable logs of pending updates */
	pending: PendingSyncUpdates;
}

export type ResourceSync = Resource<ResourceSyncConfig, ResourceSyncInfo>;

export type GetResourceSyncResponse = ResourceSync;

export enum ResourceSyncState {
	/** Last sync successful (or never synced). No Changes pending */
	Ok = "Ok",
	/** Last sync failed */
	Failed = "Failed",
	/** Currently syncing */
	Syncing = "Syncing",
	/** Updates pending */
	Pending = "Pending",
	/** Other case */
	Unknown = "Unknown",
}

export interface ResourceSyncListItemInfo {
	/** Unix timestamp of last sync, or 0 */
	last_sync_ts: I64;
	/** Short commit hash of last sync, or empty string */
	last_sync_hash: string;
	/** Commit message of last sync, or empty string */
	last_sync_message: string;
	/** The Github repo used as the source of the sync resources */
	repo: string;
	/** The branch of the repo */
	branch: string;
	/** State of the sync. Reflects whether most recent sync successful. */
	state: ResourceSyncState;
}

export type ResourceSyncListItem = ResourceListItem<ResourceSyncListItemInfo>;

export type ListResourceSyncsResponse = ResourceSyncListItem[];

export type ListFullResourceSyncsResponse = ResourceSync[];

export interface ResourceSyncActionState {
	/** Whether sync currently syncing */
	syncing: boolean;
}

export type GetResourceSyncActionStateResponse = ResourceSyncActionState;

export interface Tag {
	/**
	 * The Mongo ID of the tag.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Tag) }`
	 */
	_id?: MongoId;
	name: string;
	owner?: string;
}

export type GetTagResponse = Tag;

export type ListTagsResponse = Tag[];

/** Response containing pretty formatted toml contents. */
export interface TomlResponse {
	toml: string;
}

export type ExportAllResourcesToTomlResponse = TomlResponse;

export type ExportResourcesToTomlResponse = TomlResponse;

export enum Operation {
	None = "None",
	CreateServer = "CreateServer",
	UpdateServer = "UpdateServer",
	DeleteServer = "DeleteServer",
	RenameServer = "RenameServer",
	PruneImages = "PruneImages",
	PruneContainers = "PruneContainers",
	PruneNetworks = "PruneNetworks",
	CreateNetwork = "CreateNetwork",
	DeleteNetwork = "DeleteNetwork",
	StopAllContainers = "StopAllContainers",
	CreateBuild = "CreateBuild",
	UpdateBuild = "UpdateBuild",
	DeleteBuild = "DeleteBuild",
	RunBuild = "RunBuild",
	CancelBuild = "CancelBuild",
	CreateBuilder = "CreateBuilder",
	UpdateBuilder = "UpdateBuilder",
	DeleteBuilder = "DeleteBuilder",
	CreateDeployment = "CreateDeployment",
	UpdateDeployment = "UpdateDeployment",
	DeleteDeployment = "DeleteDeployment",
	Deploy = "Deploy",
	StopContainer = "StopContainer",
	StartContainer = "StartContainer",
	RemoveContainer = "RemoveContainer",
	RenameDeployment = "RenameDeployment",
	CreateRepo = "CreateRepo",
	UpdateRepo = "UpdateRepo",
	DeleteRepo = "DeleteRepo",
	CloneRepo = "CloneRepo",
	PullRepo = "PullRepo",
	CreateAlerter = "CreateAlerter",
	UpdateAlerter = "UpdateAlerter",
	DeleteAlerter = "DeleteAlerter",
	CreateProcedure = "CreateProcedure",
	UpdateProcedure = "UpdateProcedure",
	DeleteProcedure = "DeleteProcedure",
	RunProcedure = "RunProcedure",
	CreateServerTemplate = "CreateServerTemplate",
	UpdateServerTemplate = "UpdateServerTemplate",
	DeleteServerTemplate = "DeleteServerTemplate",
	LaunchServer = "LaunchServer",
	CreateResourceSync = "CreateResourceSync",
	UpdateResourceSync = "UpdateResourceSync",
	DeleteResourceSync = "DeleteResourceSync",
	RunSync = "RunSync",
	CreateVariable = "CreateVariable",
	UpdateVariableValue = "UpdateVariableValue",
	DeleteVariable = "DeleteVariable",
}

/** An update's status */
export enum UpdateStatus {
	/** The run is in the system but hasn't started yet */
	Queued = "Queued",
	/** The run is currently running */
	InProgress = "InProgress",
	/** The run is complete */
	Complete = "Complete",
}

/** Represents an action performed by Monitor. */
export interface Update {
	/**
	 * The Mongo ID of the update.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized Update) }`
	 */
	_id?: MongoId;
	/** The operation performed */
	operation: Operation;
	/** The time the operation started */
	start_ts: I64;
	/** Whether the operation was successful */
	success: boolean;
	/**
	 * The user id that triggered the update.
	 * 
	 * Also can take these values for operations triggered automatically:
	 * - `Procedure`: The operation was triggered as part of a procedure run
	 * - `Github`: The operation was triggered by a github webhook
	 * - `Auto Redeploy`: The operation (always `Deploy`) was triggered by an attached build finishing.
	 */
	operator: string;
	/** The target resource to which this update refers */
	target: ResourceTarget;
	/** Logs produced as the operation is performed */
	logs: Log[];
	/** The time the operation completed. */
	end_ts?: I64;
	/**
	 * The status of the update
	 * - `Queued`
	 * - `InProgress`
	 * - `Complete`
	 */
	status: UpdateStatus;
	/** An optional version on the update, ie build version or deployed version. */
	version?: Version;
	/** Some unstructured, operation specific data. Not for general usage. */
	other_data?: string;
}

export type GetUpdateResponse = Update;

/** An api key used to authenticate requests via request headers. */
export interface ApiKey {
	/** Unique key associated with secret */
	key: string;
	/** Hash of the secret */
	secret: string;
	/** User associated with the api key */
	user_id: string;
	/** Name associated with the api key for management */
	name: string;
	/** Timestamp of key creation */
	created_at: I64;
	/** Expiry of key, or 0 if never expires */
	expires: I64;
}

export type ListApiKeysResponse = ApiKey[];

export type ListApiKeysForServiceUserResponse = ApiKey[];

export type FindUserResponse = User;

export type ListUsersResponse = User[];

/**
 * Permission users at the group level.
 * 
 * All users that are part of a group inherit the group's permissions.
 * A user can be a part of multiple groups. A user's permission on a particular resource
 * will be resolved to be the maximum permission level between the user's own permissions and
 * any groups they are a part of.
 */
export interface UserGroup {
	/**
	 * The Mongo ID of the UserGroup.
	 * This field is de/serialized from/to JSON as
	 * `{ "_id": { "$oid": "..." }, ...(rest of serialized User) }`
	 */
	_id?: MongoId;
	/** A name for the user group */
	name: string;
	/** User ids of group members */
	users: string[];
	/** Give the user group elevated permissions on all resources of a certain type */
	all?: Record<ResourceTarget["type"], PermissionLevel>;
	/** Unix time (ms) when user group last updated */
	updated_at?: I64;
}

export type GetUserGroupResponse = UserGroup;

export type ListUserGroupsResponse = UserGroup[];

/**
 * A non-secret global variable which can be interpolated into deployment
 * environment variable values and build argument values.
 */
export interface Variable {
	/**
	 * Unique name associated with the variable.
	 * Instances of '[[variable.name]]' in value will be replaced with 'variable.value'.
	 */
	name: string;
	/** A description for the variable. */
	description?: string;
	/** The value associated with the variable. */
	value?: string;
}

export type GetVariableResponse = Variable;

export type PushRecentlyViewedResponse = NoData;

export type SetLastSeenUpdateResponse = NoData;

export type DeleteApiKeyResponse = NoData;

/** Response for [CreateApiKey]. */
export interface CreateApiKeyResponse {
	/** X-API-KEY */
	key: string;
	/**
	 * X-API-SECRET
	 * 
	 * Note.
	 * There is no way to get the secret again after it is distributed in this message
	 */
	secret: string;
}

export type CreateApiKeyForServiceUserResponse = CreateApiKeyResponse;

export type DeleteApiKeyForServiceUserResponse = NoData;

export type CreateBuildWebhookResponse = NoData;

export type DeleteBuildWebhookResponse = NoData;

export type UpdateDescriptionResponse = NoData;

export type UpdatePermissionOnTargetResponse = NoData;

export type UpdatePermissionOnResourceTypeResponse = NoData;

export type UpdateUserBasePermissionsResponse = NoData;

export type CreateProcedureResponse = Procedure;

export type CopyProcedureResponse = Procedure;

export type DeleteProcedureResponse = Procedure;

export type UpdateProcedureResponse = Procedure;

export type CreateRepoWebhookResponse = NoData;

export type DeleteRepoWebhookResponse = NoData;

export type CreateSyncWebhookResponse = NoData;

export type DeleteSyncWebhookResponse = NoData;

export type UpdateTagsOnResourceResponse = NoData;

export type CreateServiceUserResponse = User;

export type UpdateServiceUserDescriptionResponse = User;

export type CreateVariableResponse = Variable;

export type UpdateVariableValueResponse = Variable;

export type UpdateVariableDescriptionResponse = Variable;

export type DeleteVariableResponse = Variable;

export type _PartialAlerterConfig = Partial<AlerterConfig>;

export enum TagBehavior {
	/** Returns resources which have strictly all the tags */
	All = "All",
	/** Returns resources which have one or more of the tags */
	Any = "Any",
}

/** Passing empty Vec is the same as not filtering by that field */
export interface ResourceQuery<T> {
	ids?: string[];
	names?: string[];
	/** Pass Vec of tag ids or tag names */
	tags?: string[];
	tag_behavior?: TagBehavior;
	specific?: T;
}

export interface AlerterQuerySpecifics {
	/**
	 * Filter alerters by enabled.
	 * - `None`: Don't filter by enabled
	 * - `Some(true)`: Only include alerts with `enabled: true`
	 * - `Some(false)`: Only include alerts with `enabled: false`
	 */
	enabled?: boolean;
	/**
	 * Only include alerters with these endpoint types.
	 * If empty, don't filter by enpoint type.
	 */
	types: AlerterEndpoint["type"][];
}

export type AlerterQuery = ResourceQuery<AlerterQuerySpecifics>;

export type _PartialBuildConfig = Partial<BuildConfig>;

export interface BuildQuerySpecifics {
	builder_ids?: string[];
	repos?: string[];
	/**
	 * query for builds last built more recently than this timestamp
	 * defaults to 0 which is a no op
	 */
	built_since?: I64;
}

export type BuildQuery = ResourceQuery<BuildQuerySpecifics>;

export type _PartialBuilderConfig = Partial<BuilderConfig>;

export type _PartialServerBuilderConfig = Partial<ServerBuilderConfig>;

export type _PartialAwsBuilderConfig = Partial<AwsBuilderConfig>;

export interface BuilderQuerySpecifics {
}

export type BuilderQuery = ResourceQuery<BuilderQuerySpecifics>;

export type _PartialDeploymentConfig = Partial<DeploymentConfig>;

export interface DeploymentQuerySpecifics {
	server_ids?: string[];
	build_ids?: string[];
}

export type DeploymentQuery = ResourceQuery<DeploymentQuerySpecifics>;

export type U64 = number;

export type MongoDocument = any;

export interface __Serror {
	error: string;
	trace: string[];
}

export type _Serror = __Serror;

export type _PartialProcedureConfig = Partial<ProcedureConfig>;

export interface ProcedureQuerySpecifics {
}

export type ProcedureQuery = ResourceQuery<ProcedureQuerySpecifics>;

export type _PartialRepoConfig = Partial<RepoConfig>;

export interface RepoQuerySpecifics {
	/** Filter repos by their repo. */
	repos: string[];
}

export type RepoQuery = ResourceQuery<RepoQuerySpecifics>;

export type _PartialServerConfig = Partial<ServerConfig>;

export interface ServerQuerySpecifics {
}

/** Server-specific query */
export type ServerQuery = ResourceQuery<ServerQuerySpecifics>;

export type _PartialAwsServerTemplateConfig = Partial<AwsServerTemplateConfig>;

export type _PartialHetznerServerTemplateConfig = Partial<HetznerServerTemplateConfig>;

export interface ServerTemplateQuerySpecifics {
	types: ServerTemplateConfig["type"][];
}

export type ServerTemplateQuery = ResourceQuery<ServerTemplateQuerySpecifics>;

export type _PartialResourceSyncConfig = Partial<ResourceSyncConfig>;

export interface ResourceSyncQuerySpecifics {
	/** Filter syncs by their repo. */
	repos: string[];
}

export type ResourceSyncQuery = ResourceQuery<ResourceSyncQuerySpecifics>;

export type _PartialTag = Partial<Tag>;

/**
 * Non authenticated route to see the available options
 * users have to login to monitor, eg. local auth, github, google.
 * Response: [GetLoginOptionsResponse].
 */
export interface GetLoginOptions {
}

/** The response for [GetLoginOptions]. */
export interface GetLoginOptionsResponse {
	/** Whether local auth is enabled. */
	local: boolean;
	/** Whether github login is enabled. */
	github: boolean;
	/** Whether google login is enabled. */
	google: boolean;
}

/**
 * Create a new local user account. Will fail if a user with the
 * given username already exists.
 * Response: [CreateLocalUserResponse].
 * 
 * Note. This method is only available if the core api has `local_auth` enabled.
 */
export interface CreateLocalUser {
	/** The username for the new user. */
	username: string;
	/**
	 * The password for the new user.
	 * This cannot be retreived later.
	 */
	password: string;
}

/**
 * Login as a local user. Will fail if the users credentials don't match
 * any local user.
 * 
 * Note. This method is only available if the core api has `local_auth` enabled.
 */
export interface LoginLocalUser {
	/** The user's username */
	username: string;
	/** The user's password */
	password: string;
}

/**
 * Exchange a single use exchange token (safe for transport in url query)
 * for a jwt.
 * Response: [ExchangeForJwtResponse].
 */
export interface ExchangeForJwt {
	/** The 'exchange token' */
	token: string;
}

/**
 * Get the user extracted from the request headers.
 * Response: [User].
 */
export interface GetUser {
}

/**
 * Runs the target build. Response: [Update].
 * 
 * 1. Get a handle to the builder. If using AWS builder, this means starting a builder ec2 instance.
 * 2. Clone the repo on the builder. If an `on_clone` commmand is given, it will be executed.
 * 3. Execute `docker build {...params}`, where params are determined using the builds configuration.
 * 4. If a dockerhub account is attached, the build will be pushed to that account.
 */
export interface RunBuild {
	/** Can be build id or name */
	build: string;
}

/**
 * Cancels the target build.
 * Only does anything if the build is `building` when called.
 * Response: [Update]
 */
export interface CancelBuild {
	/** Can be id or name */
	build: string;
}

/**
 * Deploys the container for the target deployment. Response: [Update].
 * 
 * 1. Pulls the image onto the target server.
 * 2. If the container is already running,
 * it will be stopped and removed using `docker container rm ${container_name}`.
 * 3. The container will be run using `docker run {...params}`,
 * where params are determined by the deployment's configuration.
 */
export interface Deploy {
	/** Name or id */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	stop_signal?: TerminationSignal;
	/** Override the default termination max time. */
	stop_time?: number;
}

/**
 * Starts the container for the target deployment. Response: [Update]
 * 
 * 1. Runs `docker start ${container_name}`.
 */
export interface StartContainer {
	/** Name or id */
	deployment: string;
}

/**
 * Stops the container for the target deployment. Response: [Update]
 * 
 * 1. Runs `docker stop ${container_name}`.
 */
export interface StopContainer {
	/** Name or id */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	signal?: TerminationSignal;
	/** Override the default termination max time. */
	time?: number;
}

/**
 * Stops all deployments on the target server. Response: [Update]
 * 
 * 1. Runs [StopContainer] on all deployments on the server concurrently.
 */
export interface StopAllContainers {
	/** Name or id */
	server: string;
}

/**
 * Stops and removes the container for the target deployment.
 * Reponse: [Update].
 * 
 * 1. The container is stopped and removed using `docker container rm ${container_name}`.
 */
export interface RemoveContainer {
	/** Name or id. */
	deployment: string;
	/** Override the default termination signal specified in the deployment. */
	signal?: TerminationSignal;
	/** Override the default termination max time. */
	time?: number;
}

export interface Sleep {
	duration_ms?: I64;
}

/** Runs the target procedure. Response: [Update] */
export interface RunProcedure {
	/** Id or name */
	procedure: string;
}

/**
 * Clones the target repo. Response: [Update].
 * 
 * 1. Clones the repo on the target server using `git clone https://{$token?}@github.com/${repo} -b ${branch}`.
 * The token will only be used if a github account is specified,
 * and must be declared in the periphery configuration on the target server.
 * 2. If `on_clone` and `on_pull` are specified, they will be executed.
 * `on_clone` will be executed before `on_pull`.
 */
export interface CloneRepo {
	/** Id or name */
	repo: string;
}

/**
 * Pulls the target repo. Response: [Update].
 * 
 * 1. Pulls the repo on the target server using `git pull`.
 * 2. If `on_pull` is specified, it will be executed after the pull is complete.
 */
export interface PullRepo {
	/** Id or name */
	repo: string;
}

/**
 * Prunes the docker networks on the target server. Response: [Update].
 * 
 * 1. Runs `docker network prune -f`.
 */
export interface PruneNetworks {
	/** Id or name */
	server: string;
}

/**
 * Prunes the docker images on the target server. Response: [Update].
 * 
 * 1. Runs `docker image prune -a -f`.
 */
export interface PruneImages {
	/** Id or name */
	server: string;
}

/**
 * Prunes the docker containers on the target server. Response: [Update].
 * 
 * 1. Runs `docker container prune -f`.
 */
export interface PruneContainers {
	/** Id or name */
	server: string;
}

/**
 * Launch an EC2 instance with the specified config.
 * Response: [Update].
 */
export interface LaunchServer {
	/** The name of the created server. */
	name: string;
	/** The server template used to define the config. */
	server_template: string;
}

/** Runs the target resource sync. Response: [Update] */
export interface RunSync {
	/** Id or name */
	sync: string;
}

/**
 * Get a paginated list of alerts sorted by timestamp descending.
 * Response: [ListAlertsResponse].
 */
export interface ListAlerts {
	/**
	 * Pass a custom mongo query to filter the alerts.
	 * 
	 * ## Example JSON
	 * ```
	 * {
	 * "resolved": "false",
	 * "level": "CRITICAL",
	 * "$or": [
	 * {
	 * "target": {
	 * "type": "Server",
	 * "id": "6608bf89cb2a12b257ab6c09"
	 * }
	 * },
	 * {
	 * "target": {
	 * "type": "Server",
	 * "id": "660a5f60b74f90d5dae45fa3"
	 * }
	 * }
	 * ]
	 * }
	 * ```
	 * This will filter to only include open alerts that have CRITICAL level on those two servers.
	 */
	query?: MongoDocument;
	/**
	 * Retrieve older results by incrementing the page.
	 * `page: 0` is default, and returns the most recent results.
	 */
	page?: U64;
}

/** Response for [ListAlerts]. */
export interface ListAlertsResponse {
	alerts: Alert[];
	/**
	 * If more alerts exist, the next page will be given here.
	 * Otherwise it will be `null`
	 */
	next_page?: I64;
}

/** Get an alert: Response: [Alert]. */
export interface GetAlert {
	id: string;
}

/** Get a specific alerter. Response: [Alerter]. */
export interface GetAlerter {
	/** Id or name */
	alerter: string;
}

/** List alerters matching optional query. Response: [ListAlertersResponse]. */
export interface ListAlerters {
	/** Structured query to filter alerters. */
	query?: AlerterQuery;
}

/** List full alerters matching optional query. Response: [ListFullAlertersResponse]. */
export interface ListFullAlerters {
	/** Structured query to filter alerters. */
	query?: AlerterQuery;
}

/**
 * Gets a summary of data relating to all alerters.
 * Response: [GetAlertersSummaryResponse].
 */
export interface GetAlertersSummary {
}

/** Response for [GetAlertersSummary]. */
export interface GetAlertersSummaryResponse {
	total: number;
}

/** Get a specific build. Response: [Build]. */
export interface GetBuild {
	/** Id or name */
	build: string;
}

/** List builds matching optional query. Response: [ListBuildsResponse]. */
export interface ListBuilds {
	/** optional structured query to filter builds. */
	query?: BuildQuery;
}

/** List builds matching optional query. Response: [ListFullBuildsResponse]. */
export interface ListFullBuilds {
	/** optional structured query to filter builds. */
	query?: BuildQuery;
}

/** Get current action state for the build. Response: [BuildActionState]. */
export interface GetBuildActionState {
	/** Id or name */
	build: string;
}

/**
 * Gets a summary of data relating to all builds.
 * Response: [GetBuildsSummaryResponse].
 */
export interface GetBuildsSummary {
}

/** Response for [GetBuildsSummary]. */
export interface GetBuildsSummaryResponse {
	/** The total number of builds in monitor. */
	total: number;
	/** The number of builds with Ok state. */
	ok: number;
	/** The number of builds with Failed state. */
	failed: number;
	/** The number of builds currently building. */
	building: number;
	/** The number of builds with unknown state. */
	unknown: number;
}

/**
 * Gets summary and timeseries breakdown of the last months build count / time for charting.
 * Response: [GetBuildMonthlyStatsResponse].
 * 
 * Note. This method is paginated. One page is 30 days of data.
 * Query for older pages by incrementing the page, starting at 0.
 */
export interface GetBuildMonthlyStats {
	/**
	 * Query for older data by incrementing the page.
	 * `page: 0` is the default, and will return the most recent data.
	 */
	page?: number;
}

/** Item in [GetBuildMonthlyStatsResponse] */
export interface BuildStatsDay {
	time: number;
	count: number;
	ts: number;
}

/** Response for [GetBuildMonthlyStats]. */
export interface GetBuildMonthlyStatsResponse {
	total_time: number;
	total_count: number;
	days: BuildStatsDay[];
}

/**
 * Retrieve versions of the build that were built in the past and available for deployment,
 * sorted by most recent first.
 * Response: [GetBuildVersionsResponse].
 */
export interface GetBuildVersions {
	/** Id or name */
	build: string;
	/** Filter to only include versions matching this major version. */
	major?: number;
	/** Filter to only include versions matching this minor version. */
	minor?: number;
	/** Filter to only include versions matching this patch version. */
	patch?: number;
	/** Limit the number of included results. Default is no limit. */
	limit?: I64;
}

/**
 * List the available github organizations which can be attached to builds.
 * Response: [ListGithubOrganizationsResponse].
 */
export interface ListGithubOrganizations {
}

/**
 * List the available docker organizations which can be attached to builds.
 * Response: [ListDockerOrganizationsResponse].
 */
export interface ListDockerOrganizations {
}

/**
 * Gets a list of existing values used as extra args across other builds.
 * Useful to offer suggestions. Response: [ListCommonBuildExtraArgsResponse]
 */
export interface ListCommonBuildExtraArgs {
	/** optional structured query to filter builds. */
	query?: BuildQuery;
}

/** Get whether a Build's target repo has a webhook for the build configured. Response: [GetBuildWebhookEnabledResponse]. */
export interface GetBuildWebhookEnabled {
	/** Id or name */
	build: string;
}

/** Response for [GetBuildWebhookEnabled] */
export interface GetBuildWebhookEnabledResponse {
	/**
	 * Whether the repo webhooks can even be managed.
	 * The repo owner must be in `github_webhook_app.owners` list to be managed.
	 */
	managed: boolean;
	/** Whether pushes to branch trigger build. Will always be false if managed is false. */
	enabled: boolean;
}

/** Get a specific builder by id or name. Response: [Builder]. */
export interface GetBuilder {
	/** Id or name */
	builder: string;
}

/** List builders matching structured query. Response: [ListBuildersResponse]. */
export interface ListBuilders {
	query?: BuilderQuery;
}

/** List builders matching structured query. Response: [ListFullBuildersResponse]. */
export interface ListFullBuilders {
	query?: BuilderQuery;
}

/**
 * Gets a summary of data relating to all builders.
 * Response: [GetBuildersSummaryResponse].
 */
export interface GetBuildersSummary {
}

/** Response for [GetBuildersSummary]. */
export interface GetBuildersSummaryResponse {
	/** The total number of builders. */
	total: number;
}

/**
 * Get the docker / github accounts which are available for use on the builder.
 * Response: [GetBuilderAvailableAccountsResponse].
 * 
 * Note. Builds using this builder can only use the docker / github accounts available in this response.
 */
export interface GetBuilderAvailableAccounts {
	/** Id or name */
	builder: string;
}

/** Response for [GetBuilderAvailableAccounts]. */
export interface GetBuilderAvailableAccountsResponse {
	github: string[];
	docker: string[];
}

/** Get a specific deployment by name or id. Response: [Deployment]. */
export interface GetDeployment {
	/** Id or name */
	deployment: string;
}

/**
 * List deployments matching optional query.
 * Response: [ListDeploymentsResponse].
 */
export interface ListDeployments {
	/** optional structured query to filter deployments. */
	query?: DeploymentQuery;
}

/**
 * List deployments matching optional query.
 * Response: [ListFullDeploymentsResponse].
 */
export interface ListFullDeployments {
	/** optional structured query to filter deployments. */
	query?: DeploymentQuery;
}

/**
 * Get the container, including image / status, of the target deployment.
 * Response: [GetDeploymentContainerResponse].
 * 
 * Note. This does not hit the server directly. The status comes from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetDeploymentContainer {
	/** Id or name */
	deployment: string;
}

/** Response for [GetDeploymentContainer]. */
export interface GetDeploymentContainerResponse {
	state: DeploymentState;
	container?: ContainerSummary;
}

/**
 * Get the deployment log's tail, split by stdout/stderr.
 * Response: [Log].
 * 
 * Note. This call will hit the underlying server directly for most up to date log.
 */
export interface GetLog {
	/** Id or name */
	deployment: string;
	/**
	 * The number of lines of the log tail to include.
	 * Default: 100.
	 * Max: 5000.
	 */
	tail: U64;
}

export enum SearchCombinator {
	Or = "Or",
	And = "And",
}

/**
 * Search the deployment log's tail using `grep`. All lines go to stdout.
 * Response: [Log].
 * 
 * Note. This call will hit the underlying server directly for most up to date log.
 */
export interface SearchLog {
	/** Id or name */
	deployment: string;
	/** The terms to search for. */
	terms: string[];
	/**
	 * When searching for multiple terms, can use `AND` or `OR` combinator.
	 * 
	 * - `AND`: Only include lines with **all** terms present in that line.
	 * - `OR`: Include lines that have one or more matches in the terms.
	 */
	combinator?: SearchCombinator;
	/** Invert the results, ie return all lines that DON'T match the terms / combinator. */
	invert?: boolean;
}

/**
 * Get the deployment container's stats using `docker stats`.
 * Response: [DockerContainerStats].
 * 
 * Note. This call will hit the underlying server directly for most up to date stats.
 */
export interface GetDeploymentStats {
	/** Id or name */
	deployment: string;
}

/**
 * Get current action state for the deployment.
 * Response: [DeploymentActionState].
 */
export interface GetDeploymentActionState {
	/** Id or name */
	deployment: string;
}

/**
 * Gets a summary of data relating to all deployments.
 * Response: [GetDeploymentsSummaryResponse].
 */
export interface GetDeploymentsSummary {
}

/** Response for [GetDeploymentsSummary]. */
export interface GetDeploymentsSummaryResponse {
	total: I64;
	running: I64;
	stopped: I64;
	not_deployed: I64;
	unknown: I64;
}

/**
 * Gets a list of existing values used as extra args across other deployments.
 * Useful to offer suggestions. Response: [ListCommonDeploymentExtraArgsResponse]
 */
export interface ListCommonDeploymentExtraArgs {
	/** optional structured query to filter deployments. */
	query?: DeploymentQuery;
}

/**
 * Get the version of the core api.
 * Response: [GetVersionResponse].
 */
export interface GetVersion {
}

/** Response for [GetVersion]. */
export interface GetVersionResponse {
	/** The version of the core api. */
	version: string;
}

/**
 * Get info about the core api.
 * Response: [GetCoreInfoResponse].
 */
export interface GetCoreInfo {
}

/** Response for [GetCoreInfo]. */
export interface GetCoreInfoResponse {
	/** The title assigned to this core api. */
	title: string;
	/** The monitoring interval of this core api. */
	monitoring_interval: Timelength;
	/** The github webhook base url to use with github webhooks. */
	github_webhook_base_url: string;
	/** Whether transparent mode is enabled, which gives all users read access to all resources. */
	transparent_mode: boolean;
	/** Whether UI write access should be disabled */
	ui_write_disabled: boolean;
	/** The repo owners for which github webhook management api is available */
	github_webhook_owners: string[];
}

/**
 * Get the available aws ecr config labels from the core config.
 * Response: [GetAvailableAwsEcrLabelsResponse].
 */
export interface GetAvailableAwsEcrLabels {
}

/**
 * List permissions for the calling user.
 * Does not include any permissions on UserGroups they may be a part of.
 * Response: [ListPermissionsResponse]
 */
export interface ListPermissions {
}

/**
 * Gets the calling user's permission level on a specific resource.
 * Factors in any UserGroup's permissions they may be a part of.
 * Response: [PermissionLevel]
 */
export interface GetPermissionLevel {
	/** The target to get user permission on. */
	target: ResourceTarget;
}

/**
 * List permissions for a specific user. **Admin only**.
 * Response: [ListUserTargetPermissionsResponse]
 */
export interface ListUserTargetPermissions {
	/** Specify either a user or a user group. */
	user_target: UserTarget;
}

/** Get a specific procedure. Response: [Procedure]. */
export interface GetProcedure {
	/** Id or name */
	procedure: string;
}

/** List procedures matching optional query. Response: [ListProceduresResponse]. */
export interface ListProcedures {
	/** optional structured query to filter procedures. */
	query?: ProcedureQuery;
}

/** List procedures matching optional query. Response: [ListFullProceduresResponse]. */
export interface ListFullProcedures {
	/** optional structured query to filter procedures. */
	query?: ProcedureQuery;
}

/** Get current action state for the procedure. Response: [ProcedureActionState]. */
export interface GetProcedureActionState {
	/** Id or name */
	procedure: string;
}

/**
 * Gets a summary of data relating to all procedures.
 * Response: [GetProceduresSummaryResponse].
 */
export interface GetProceduresSummary {
}

/** Response for [GetProceduresSummary]. */
export interface GetProceduresSummaryResponse {
	/** The total number of procedures. */
	total: number;
	/** The number of procedures with Ok state. */
	ok: number;
	/** The number of procedures currently running. */
	running: number;
	/** The number of procedures with failed state. */
	failed: number;
	/** The number of procedures with unknown state. */
	unknown: number;
}

/** Get a specific repo. Response: [Repo]. */
export interface GetRepo {
	/** Id or name */
	repo: string;
}

/** List repos matching optional query. Response: [ListReposResponse]. */
export interface ListRepos {
	/** optional structured query to filter repos. */
	query?: RepoQuery;
}

/** List repos matching optional query. Response: [ListFullReposResponse]. */
export interface ListFullRepos {
	/** optional structured query to filter repos. */
	query?: RepoQuery;
}

/** Get current action state for the repo. Response: [RepoActionState]. */
export interface GetRepoActionState {
	/** Id or name */
	repo: string;
}

/**
 * Gets a summary of data relating to all repos.
 * Response: [GetReposSummaryResponse].
 */
export interface GetReposSummary {
}

/** Response for [GetReposSummary] */
export interface GetReposSummaryResponse {
	/** The total number of repos */
	total: number;
	/** The number of repos with Ok state. */
	ok: number;
	/** The number of repos currently cloning. */
	cloning: number;
	/** The number of repos currently pulling. */
	pulling: number;
	/** The number of repos with failed state. */
	failed: number;
	/** The number of repos with unknown state. */
	unknown: number;
}

/** Get a target Repo's configured webhooks. Response: [GetRepoWebhooksEnabledResponse]. */
export interface GetRepoWebhooksEnabled {
	/** Id or name */
	repo: string;
}

/** Response for [GetRepoWebhooksEnabled] */
export interface GetRepoWebhooksEnabledResponse {
	/**
	 * Whether the repo webhooks can even be managed.
	 * The repo owner must be in `github_webhook_app.owners` list to be managed.
	 */
	managed: boolean;
	/** Whether pushes to branch trigger clone. Will always be false if managed is false. */
	clone_enabled: boolean;
	/** Whether pushes to branch trigger pull. Will always be false if managed is false. */
	pull_enabled: boolean;
}

/** Find resources matching a common query. Response: [FindResourcesResponse]. */
export interface FindResources {
	/** The mongo query as JSON */
	query?: MongoDocument;
	/** The resource variants to include in the response. */
	resources?: ResourceTarget["type"][];
}

/** Response for [FindResources]. */
export interface FindResourcesResponse {
	/** The matching servers. */
	servers: ServerListItem[];
	/** The matching deployments. */
	deployments: DeploymentListItem[];
	/** The matching builds. */
	builds: BuildListItem[];
	/** The matching repos. */
	repos: RepoListItem[];
	/** The matching procedures. */
	procedures: ProcedureListItem[];
}

/** Get a specific server. Response: [Server]. */
export interface GetServer {
	/** Id or name */
	server: string;
}

/** List servers matching optional query. Response: [ListServersResponse]. */
export interface ListServers {
	/** optional structured query to filter servers. */
	query?: ServerQuery;
}

/** List servers matching optional query. Response: [ListFullServersResponse]. */
export interface ListFullServers {
	/** optional structured query to filter servers. */
	query?: ServerQuery;
}

/** Get the state of the target server. Response: [GetServerStateResponse]. */
export interface GetServerState {
	/** Id or name */
	server: string;
}

/** The response for [GetServerState]. */
export interface GetServerStateResponse {
	/** The server status. */
	status: ServerState;
}

/** Get current action state for the servers. Response: [ServerActionState]. */
export interface GetServerActionState {
	/** Id or name */
	server: string;
}

/**
 * Get the version of the monitor periphery agent on the target server.
 * Response: [GetPeripheryVersionResponse].
 */
export interface GetPeripheryVersion {
	/** Id or name */
	server: string;
}

/** Response for [GetPeripheryVersion]. */
export interface GetPeripheryVersionResponse {
	/** The version of periphery. */
	version: string;
}

/** Get the docker networks on the server. Response: [GetDockerNetworksResponse]. */
export interface GetDockerNetworks {
	/** Id or name */
	server: string;
}

/**
 * Get the docker images locally cached on the target server.
 * Response: [GetDockerImagesResponse].
 */
export interface GetDockerImages {
	/** Id or name */
	server: string;
}

/**
 * Get all docker containers on the target server.
 * Response: [GetDockerContainersResponse].
 */
export interface GetDockerContainers {
	/** Id or name */
	server: string;
}

/**
 * Get the system information of the target server.
 * Response: [SystemInformation].
 */
export interface GetSystemInformation {
	/** Id or name */
	server: string;
}

/**
 * Get the system stats on the target server. Response: [SystemStats].
 * 
 * Note. This does not hit the server directly. The stats come from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetSystemStats {
	/** Id or name */
	server: string;
}

/**
 * Get the processes running on the target server.
 * Response: [GetSystemProcessesResponse].
 * 
 * Note. This does not hit the server directly. The procedures come from an
 * in memory cache on the core, which hits the server periodically
 * to keep it up to date.
 */
export interface GetSystemProcesses {
	/** Id or name */
	server: string;
}

/**
 * Paginated endpoint serving historical (timeseries) server stats for graphing.
 * Response: [GetHistoricalServerStatsResponse].
 */
export interface GetHistoricalServerStats {
	/** Id or name */
	server: string;
	/** The granularity of the data. */
	granularity: Timelength;
	/**
	 * Page of historical data. Default is 0, which is the most recent data.
	 * Use with the `next_page` field of the response.
	 */
	page?: number;
}

/** System stats stored on the database. */
export interface SystemStatsRecord {
	/** Unix timestamp in milliseconds */
	ts: I64;
	/** Server id */
	sid: string;
	/** Cpu usage percentage */
	cpu_perc: number;
	/** Memory used in GB */
	mem_used_gb: number;
	/** Total memory in GB */
	mem_total_gb: number;
	/** Disk used in GB */
	disk_used_gb: number;
	/** Total disk size in GB */
	disk_total_gb: number;
	/** Breakdown of individual disks, ie their usages, sizes, and mount points */
	disks: SingleDiskUsage[];
}

/** Response to [GetHistoricalServerStats]. */
export interface GetHistoricalServerStatsResponse {
	/** The timeseries page of data. */
	stats: SystemStatsRecord[];
	/** If there is a next page of data, pass this to `page` to get it. */
	next_page?: number;
}

/**
 * Gets a summary of data relating to all servers.
 * Response: [GetServersSummaryResponse].
 */
export interface GetServersSummary {
}

/** Response for [GetServersSummary]. */
export interface GetServersSummaryResponse {
	/** The total number of servers. */
	total: I64;
	/** The number of healthy (`status: OK`) servers. */
	healthy: I64;
	/** The number of unhealthy servers. */
	unhealthy: I64;
	/** The number of disabled servers. */
	disabled: I64;
}

/**
 * Get the usernames for the available github / docker accounts
 * on the target server, or only available globally if no server
 * is provided.
 * 
 * Response: [GetAvailableAccountsResponse].
 */
export interface GetAvailableAccounts {
	/** Id or name */
	server?: string;
}

/** Response for [GetAvailableAccounts]. */
export interface GetAvailableAccountsResponse {
	/** The github usernames */
	github: string[];
	/** The docker usernames. */
	docker: string[];
}

/**
 * Get the keys for available secrets on the target server.
 * Response: [GetAvailableSecretsResponse].
 */
export interface GetAvailableSecrets {
	/** Id or name */
	server: string;
}

/** Get a specific server template by id or name. Response: [ServerTemplate]. */
export interface GetServerTemplate {
	/** Id or name */
	server_template: string;
}

/** List server templates matching structured query. Response: [ListServerTemplatesResponse]. */
export interface ListServerTemplates {
	query?: ServerTemplateQuery;
}

/** List server templates matching structured query. Response: [ListFullServerTemplatesResponse]. */
export interface ListFullServerTemplates {
	query?: ServerTemplateQuery;
}

/**
 * Gets a summary of data relating to all server templates.
 * Response: [GetServerTemplatesSummaryResponse].
 */
export interface GetServerTemplatesSummary {
}

/** Response for [GetServerTemplatesSummary]. */
export interface GetServerTemplatesSummaryResponse {
	/** The total number of server templates. */
	total: number;
}

/** Get a specific sync. Response: [ResourceSync]. */
export interface GetResourceSync {
	/** Id or name */
	sync: string;
}

/** List syncs matching optional query. Response: [ListResourceSyncsResponse]. */
export interface ListResourceSyncs {
	/** optional structured query to filter syncs. */
	query?: ResourceSyncQuery;
}

/** List syncs matching optional query. Response: [ListFullResourceSyncsResponse]. */
export interface ListFullResourceSyncs {
	/** optional structured query to filter syncs. */
	query?: ResourceSyncQuery;
}

/** Get current action state for the sync. Response: [ResourceSyncActionState]. */
export interface GetResourceSyncActionState {
	/** Id or name */
	sync: string;
}

/**
 * Gets a summary of data relating to all syncs.
 * Response: [GetResourceSyncsSummaryResponse].
 */
export interface GetResourceSyncsSummary {
}

/** Response for [GetResourceSyncsSummary] */
export interface GetResourceSyncsSummaryResponse {
	/** The total number of syncs */
	total: number;
	/** The number of syncs with Ok state. */
	ok: number;
	/** The number of syncs currently syncing. */
	syncing: number;
	/** The number of syncs with pending updates */
	pending: number;
	/** The number of syncs with failed state. */
	failed: number;
	/** The number of syncs with unknown state. */
	unknown: number;
}

/** Get a target Sync's configured webhooks. Response: [GetSyncWebhooksEnabledResponse]. */
export interface GetSyncWebhooksEnabled {
	/** Id or name */
	sync: string;
}

/** Response for [GetSyncWebhooksEnabled] */
export interface GetSyncWebhooksEnabledResponse {
	/**
	 * Whether the repo webhooks can even be managed.
	 * The repo owner must be in `github_webhook_app.owners` list to be managed.
	 */
	managed: boolean;
	/** Whether pushes to branch trigger refresh. Will always be false if managed is false. */
	refresh_enabled: boolean;
	/** Whether pushes to branch trigger sync execution. Will always be false if managed is false. */
	sync_enabled: boolean;
}

/** Get data for a specific tag. Response [Tag]. */
export interface GetTag {
	/** Id or name */
	tag: string;
}

/**
 * List data for tags matching optional mongo query.
 * Response: [ListTagsResponse].
 */
export interface ListTags {
	query?: MongoDocument;
}

/**
 * Get pretty formatted monrun sync toml for all resources
 * which the user has permissions to view.
 * Response: [TomlResponse].
 */
export interface ExportAllResourcesToToml {
	/** Tag name or id. Empty array will not filter by tag. */
	tags?: string[];
}

/**
 * Get pretty formatted monrun sync toml for specific resources and user groups.
 * Response: [TomlResponse].
 */
export interface ExportResourcesToToml {
	/** The targets to include in the export. */
	targets?: ResourceTarget[];
	/** The user group names or ids to include in the export. */
	user_groups?: string[];
	/** Whether to include variables */
	include_variables?: boolean;
}

/**
 * Get all data for the target update.
 * Response: [Update].
 */
export interface GetUpdate {
	/** The update id. */
	id: string;
}

/**
 * Paginated endpoint for updates matching optional query.
 * More recent updates will be returned first.
 */
export interface ListUpdates {
	/** An optional mongo query to filter the updates. */
	query?: MongoDocument;
	/**
	 * Page of updates. Default is 0, which is the most recent data.
	 * Use with the `next_page` field of the response.
	 */
	page?: number;
}

/** Minimal representation of an action performed by Monitor. */
export interface UpdateListItem {
	/** The id of the update */
	id: string;
	/** Which operation was run */
	operation: Operation;
	/** The starting time of the operation */
	start_ts: I64;
	/** Whether the operation was successful */
	success: boolean;
	/** The username of the user performing update */
	username: string;
	/**
	 * The user id that triggered the update.
	 * 
	 * Also can take these values for operations triggered automatically:
	 * - `Procedure`: The operation was triggered as part of a procedure run
	 * - `Github`: The operation was triggered by a github webhook
	 * - `Auto Redeploy`: The operation (always `Deploy`) was triggered by an attached build finishing.
	 */
	operator: string;
	/** The target resource to which this update refers */
	target: ResourceTarget;
	/**
	 * The status of the update
	 * - `Queued`
	 * - `InProgress`
	 * - `Complete`
	 */
	status: UpdateStatus;
	/** An optional version on the update, ie build version or deployed version. */
	version?: Version;
	/** Some unstructured, operation specific data. Not for general usage. */
	other_data?: string;
}

/** Response for [ListUpdates]. */
export interface ListUpdatesResponse {
	/** The page of updates, sorted by timestamp descending. */
	updates: UpdateListItem[];
	/** If there is a next page of data, pass this to `page` to get it. */
	next_page?: number;
}

/**
 * Gets list of api keys for the calling user.
 * Response: [ListApiKeysResponse]
 */
export interface ListApiKeys {
}

/**
 * **Admin only.**
 * Gets list of api keys for the user.
 * Will still fail if you call for a user_id that isn't a service user.
 * Response: [ListApiKeysForServiceUserResponse]
 */
export interface ListApiKeysForServiceUser {
	/** Id or username */
	user: string;
}

/**
 * **Admin only.**
 * Find a user.
 * Response: [FindUserResponse]
 */
export interface FindUser {
	/** Id or username */
	user: string;
}

/**
 * **Admin only.**
 * Gets list of monitor users.
 * Response: [ListUsersResponse]
 */
export interface ListUsers {
}

/**
 * Gets the username of a specific user.
 * Response: [GetUsernameResponse]
 */
export interface GetUsername {
	/** The id of the user. */
	user_id: string;
}

/** Response for [GetUsername]. */
export interface GetUsernameResponse {
	/** The username of the user. */
	username: string;
	/** An optional icon for the user. */
	avatar?: string;
}

/**
 * Get a specific user group by name or id.
 * Response: [UserGroup].
 */
export interface GetUserGroup {
	/** Name or Id */
	user_group: string;
}

/**
 * List all user groups which user can see. Response: [ListUserGroupsResponse].
 * 
 * Admins can see all user groups,
 * and users can see user groups to which they belong.
 */
export interface ListUserGroups {
}

/**
 * List all available global variables.
 * Response: [Variable]
 */
export interface GetVariable {
	/** The name of the variable to get. */
	name: string;
}

/**
 * List all available global variables.
 * Response: [ListVariablesResponse]
 */
export interface ListVariables {
}

/** The response of [ListVariables]. */
export interface ListVariablesResponse {
	/** The available global variables. */
	variables: Variable[];
	/** The available global secret keys */
	secrets: string[];
}

/**
 * Push a resource to the front of the users 10 most recently viewed resources.
 * Response: [NoData].
 */
export interface PushRecentlyViewed {
	/** The target to push. */
	resource: ResourceTarget;
}

/**
 * Set the time the user last opened the UI updates.
 * Used for unseen notification dot.
 * Response: [NoData]
 */
export interface SetLastSeenUpdate {
}

/**
 * Create an api key for the calling user.
 * Response: [CreateApiKeyResponse].
 * 
 * Note. After the response is served, there will be no way
 * to get the secret later.
 */
export interface CreateApiKey {
	/** The name for the api key. */
	name: string;
	/**
	 * A unix timestamp in millseconds specifying api key expire time.
	 * Default is 0, which means no expiry.
	 */
	expires?: I64;
}

/**
 * Delete an api key for the calling user.
 * Response: [NoData]
 */
export interface DeleteApiKey {
	/** The key which the user intends to delete. */
	key: string;
}

/** Create an alerter. Response: [Alerter]. */
export interface CreateAlerter {
	/** The name given to newly created alerter. */
	name: string;
	/** Optional partial config to initialize the alerter with. */
	config: _PartialAlerterConfig;
}

/**
 * Creates a new alerter with given `name` and the configuration
 * of the alerter at the given `id`. Response: [Alerter].
 */
export interface CopyAlerter {
	/** The name of the new alerter. */
	name: string;
	/** The id of the alerter to copy. */
	id: string;
}

/**
 * Deletes the alerter at the given id, and returns the deleted alerter.
 * Response: [Alerter]
 */
export interface DeleteAlerter {
	/** The id or name of the alerter to delete. */
	id: string;
}

/**
 * Update the alerter at the given id, and return the updated alerter. Response: [Alerter].
 * 
 * Note. This method updates only the fields which are set in the [PartialAlerterConfig][crate::entities::alerter::PartialAlerterConfig],
 * effectively merging diffs into the final document. This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateAlerter {
	/** The id of the alerter to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialAlerterConfig;
}

/**
 * Admin only method to create an api key for a service user.
 * Response: [CreateApiKeyResponse].
 */
export interface CreateApiKeyForServiceUser {
	/** Must be service user */
	user_id: string;
	/** The name for the api key */
	name: string;
	/**
	 * A unix timestamp in millseconds specifying api key expire time.
	 * Default is 0, which means no expiry.
	 */
	expires?: I64;
}

/**
 * Admin only method to delete an api key for a service user.
 * Response: [NoData].
 */
export interface DeleteApiKeyForServiceUser {
	key: string;
}

/** Create a build. Response: [Build]. */
export interface CreateBuild {
	/** The name given to newly created build. */
	name: string;
	/** Optional partial config to initialize the build with. */
	config: _PartialBuildConfig;
}

/**
 * Creates a new build with given `name` and the configuration
 * of the build at the given `id`. Response: [Build].
 */
export interface CopyBuild {
	/** The name of the new build. */
	name: string;
	/** The id of the build to copy. */
	id: string;
}

/**
 * Deletes the build at the given id, and returns the deleted build.
 * Response: [Build]
 */
export interface DeleteBuild {
	/** The id or name of the build to delete. */
	id: string;
}

/**
 * Update the build at the given id, and return the updated build.
 * Response: [Build].
 * 
 * Note. This method updates only the fields which are set in the [_PartialBuildConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateBuild {
	/** The id of the build to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialBuildConfig;
}

/**
 * Create a webhook on the github repo attached to the build
 * passed in request. Response: [CreateBuildWebhookResponse]
 */
export interface CreateBuildWebhook {
	/** Id or name */
	build: string;
}

/**
 * Delete a webhook on the github repo attached to the build
 * passed in request. Response: [CreateBuildWebhookResponse]
 */
export interface DeleteBuildWebhook {
	/** Id or name */
	build: string;
}

/** Partial representation of [BuilderConfig] */
export type PartialBuilderConfig = 
	| { type: "Server", params: _PartialServerBuilderConfig }
	| { type: "Aws", params: _PartialAwsBuilderConfig };

/** Create a builder. Response: [Builder]. */
export interface CreateBuilder {
	/** The name given to newly created builder. */
	name: string;
	/** Optional partial config to initialize the builder with. */
	config: PartialBuilderConfig;
}

/**
 * Creates a new builder with given `name` and the configuration
 * of the builder at the given `id`. Response: [Builder]
 */
export interface CopyBuilder {
	/** The name of the new builder. */
	name: string;
	/** The id of the builder to copy. */
	id: string;
}

/**
 * Deletes the builder at the given id, and returns the deleted builder.
 * Response: [Builder]
 */
export interface DeleteBuilder {
	/** The id or name of the builder to delete. */
	id: string;
}

/**
 * Update the builder at the given id, and return the updated builder.
 * Response: [Builder].
 * 
 * Note. This method updates only the fields which are set in the [PartialBuilderConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateBuilder {
	/** The id of the builder to update. */
	id: string;
	/** The partial config update to apply. */
	config: PartialBuilderConfig;
}

/** Create a deployment. Response: [Deployment]. */
export interface CreateDeployment {
	/** The name given to newly created deployment. */
	name: string;
	/** Optional partial config to initialize the deployment with. */
	config: _PartialDeploymentConfig;
}

/**
 * Creates a new deployment with given `name` and the configuration
 * of the deployment at the given `id`. Response: [Deployment]
 */
export interface CopyDeployment {
	/** The name of the new deployment. */
	name: string;
	/** The id of the deployment to copy. */
	id: string;
}

/**
 * Deletes the deployment at the given id, and returns the deleted deployment.
 * Response: [Deployment].
 * 
 * Note. If the associated container is running, it will be deleted as part of
 * the deployment clean up.
 */
export interface DeleteDeployment {
	/** The id or name of the deployment to delete. */
	id: string;
}

/**
 * Update the deployment at the given id, and return the updated deployment.
 * Response: [Deployment].
 * 
 * Note. This method updates only the fields which are set in the [_PartialDeploymentConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateDeployment {
	/** The deployment id to update. */
	id: string;
	/** The partial config update. */
	config: _PartialDeploymentConfig;
}

/**
 * Rename the deployment at id to the given name. Response: [Update].
 * 
 * Note. If a container is created for the deployment, it will be renamed using
 * `docker rename ...`.
 */
export interface RenameDeployment {
	/** The id of the deployment to rename. */
	id: string;
	/** The new name. */
	name: string;
}

/**
 * Update a resources description.
 * Response: [NoData].
 */
export interface UpdateDescription {
	/** The target resource to set description for. */
	target: ResourceTarget;
	/** The new description. */
	description: string;
}

/**
 * **Admin only.** Update a user or user groups permission on a resource.
 * Response: [NoData].
 */
export interface UpdatePermissionOnTarget {
	/** Specify the user or user group. */
	user_target: UserTarget;
	/** Specify the target resource. */
	resource_target: ResourceTarget;
	/** Specify the permission level. */
	permission: PermissionLevel;
}

/**
 * **Admin only.** Update a user or user groups base permission level on a resource type.
 * Response: [NoData].
 */
export interface UpdatePermissionOnResourceType {
	/** Specify the user or user group. */
	user_target: UserTarget;
	/** The resource type: eg. Server, Build, Deployment, etc. */
	resource_type: ResourceTarget["type"];
	/** The base permission level. */
	permission: PermissionLevel;
}

/**
 * **Admin only.** Update a user's "base" permissions, eg. "enabled".
 * Response: [NoData].
 */
export interface UpdateUserBasePermissions {
	/** The target user. */
	user_id: string;
	/** If specified, will update users enabled state. */
	enabled?: boolean;
	/** If specified, will update user's ability to create servers. */
	create_servers?: boolean;
	/** If specified, will update user's ability to create builds. */
	create_builds?: boolean;
}

/** Create a procedure. Response: [Procedure]. */
export interface CreateProcedure {
	/** The name given to newly created build. */
	name: string;
	/** Optional partial config to initialize the procedure with. */
	config: _PartialProcedureConfig;
}

/**
 * Creates a new procedure with given `name` and the configuration
 * of the procedure at the given `id`. Response: [Procedure].
 */
export interface CopyProcedure {
	/** The name of the new procedure. */
	name: string;
	/** The id of the procedure to copy. */
	id: string;
}

/**
 * Deletes the procedure at the given id, and returns the deleted procedure.
 * Response: [Procedure]
 */
export interface DeleteProcedure {
	/** The id or name of the procedure to delete. */
	id: string;
}

/**
 * Update the procedure at the given id, and return the updated procedure.
 * Response: [Procedure].
 * 
 * Note. This method updates only the fields which are set in the [_PartialProcedureConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateProcedure {
	/** The id of the procedure to update. */
	id: string;
	/** The partial config update. */
	config: _PartialProcedureConfig;
}

/** Create a repo. Response: [Repo]. */
export interface CreateRepo {
	/** The name given to newly created repo. */
	name: string;
	/** Optional partial config to initialize the repo with. */
	config: _PartialRepoConfig;
}

/**
 * Creates a new repo with given `name` and the configuration
 * of the repo at the given `id`. Response: [Repo].
 */
export interface CopyRepo {
	/** The name of the new repo. */
	name: string;
	/** The id of the repo to copy. */
	id: string;
}

/**
 * Deletes the repo at the given id, and returns the deleted repo.
 * Response: [Repo]
 */
export interface DeleteRepo {
	/** The id or name of the repo to delete. */
	id: string;
}

/**
 * Update the repo at the given id, and return the updated repo.
 * Response: [Repo].
 * 
 * Note. If the attached server for the repo changes,
 * the repo will be deleted / cleaned up on the old server.
 * 
 * Note. This method updates only the fields which are set in the [_PartialRepoConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateRepo {
	/** The id of the repo to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialRepoConfig;
}

export enum RepoWebhookAction {
	Clone = "Clone",
	Pull = "Pull",
}

/**
 * Create a webhook on the github repo attached to the (monitor) repo
 * passed in request. Response: [CreateRepoWebhookResponse]
 */
export interface CreateRepoWebhook {
	/** Id or name */
	repo: string;
	/** "Clone" or "Pull" */
	action: RepoWebhookAction;
}

/**
 * Delete the webhook on the github repo attached to the (monitor) repo
 * passed in request. Response: [DeleteRepoWebhookResponse]
 */
export interface DeleteRepoWebhook {
	/** Id or name */
	repo: string;
	/** "Clone" or "Pull" */
	action: RepoWebhookAction;
}

/** Create a server. Response: [Server]. */
export interface CreateServer {
	/** The name given to newly created server. */
	name: string;
	/** Optional partial config to initialize the server with. */
	config: _PartialServerConfig;
}

/**
 * Deletes the server at the given id, and returns the deleted server.
 * Response: [Server]
 */
export interface DeleteServer {
	/** The id or name of the server to delete. */
	id: string;
}

/**
 * Update the server at the given id, and return the updated server.
 * Response: [Server].
 * 
 * Note. This method updates only the fields which are set in the [_PartialServerConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateServer {
	/** The id of the server to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialServerConfig;
}

/** Rename the server at id to the given name. Response: [Update]. */
export interface RenameServer {
	/** The id of the server to rename. */
	id: string;
	/** The new name. */
	name: string;
}

/**
 * Create a docker network on the server.
 * Respone: [Update]
 */
export interface CreateNetwork {
	/** Id or name */
	server: string;
	/** The name of the network to create. */
	name: string;
}

/**
 * Delete a docker network.
 * Response: [Update]
 */
export interface DeleteNetwork {
	/** Id or name. */
	server: string;
	/** The name of the network to delete. */
	name: string;
}

export type PartialServerTemplateConfig = 
	| { type: "Aws", params: _PartialAwsServerTemplateConfig }
	| { type: "Hetzner", params: _PartialHetznerServerTemplateConfig };

/** Create a server template. Response: [ServerTemplate]. */
export interface CreateServerTemplate {
	/** The name given to newly created server template. */
	name: string;
	/** Optional partial config to initialize the server template with. */
	config: PartialServerTemplateConfig;
}

/**
 * Creates a new server template with given `name` and the configuration
 * of the server template at the given `id`. Response: [ServerTemplate]
 */
export interface CopyServerTemplate {
	/** The name of the new server template. */
	name: string;
	/** The id of the server template to copy. */
	id: string;
}

/**
 * Deletes the server template at the given id, and returns the deleted server template.
 * Response: [ServerTemplate]
 */
export interface DeleteServerTemplate {
	/** The id or name of the server template to delete. */
	id: string;
}

/**
 * Update the server template at the given id, and return the updated server template.
 * Response: [ServerTemplate].
 * 
 * Note. This method updates only the fields which are set in the [PartialServerTemplateConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateServerTemplate {
	/** The id of the server template to update. */
	id: string;
	/** The partial config update to apply. */
	config: PartialServerTemplateConfig;
}

/** Create a sync. Response: [ResourceSync]. */
export interface CreateResourceSync {
	/** The name given to newly created sync. */
	name: string;
	/** Optional partial config to initialize the sync with. */
	config: _PartialResourceSyncConfig;
}

/**
 * Creates a new sync with given `name` and the configuration
 * of the sync at the given `id`. Response: [ResourceSync].
 */
export interface CopyResourceSync {
	/** The name of the new sync. */
	name: string;
	/** The id of the sync to copy. */
	id: string;
}

/**
 * Deletes the sync at the given id, and returns the deleted sync.
 * Response: [ResourceSync]
 */
export interface DeleteResourceSync {
	/** The id or name of the sync to delete. */
	id: string;
}

/**
 * Update the sync at the given id, and return the updated sync.
 * Response: [ResourceSync].
 * 
 * Note. If the attached server for the sync changes,
 * the sync will be deleted / cleaned up on the old server.
 * 
 * Note. This method updates only the fields which are set in the [_PartialResourceSyncConfig],
 * effectively merging diffs into the final document.
 * This is helpful when multiple users are using
 * the same resources concurrently by ensuring no unintentional
 * field changes occur from out of date local state.
 */
export interface UpdateResourceSync {
	/** The id of the sync to update. */
	id: string;
	/** The partial config update to apply. */
	config: _PartialResourceSyncConfig;
}

/** Trigger a refresh of the computed diff logs for view. */
export interface RefreshResourceSyncPending {
	/** Id or name */
	sync: string;
}

export enum SyncWebhookAction {
	Refresh = "Refresh",
	Sync = "Sync",
}

/**
 * Create a webhook on the github repo attached to the sync
 * passed in request. Response: [CreateSyncWebhookResponse]
 */
export interface CreateSyncWebhook {
	/** Id or name */
	sync: string;
	/** "Refresh" or "Sync" */
	action: SyncWebhookAction;
}

/**
 * Delete the webhook on the github repo attached to the sync
 * passed in request. Response: [DeleteSyncWebhookResponse]
 */
export interface DeleteSyncWebhook {
	/** Id or name */
	sync: string;
	/** "Refresh" or "Sync" */
	action: SyncWebhookAction;
}

/** Create a tag. Response: [Tag]. */
export interface CreateTag {
	/** The name of the tag. */
	name: string;
}

/**
 * Delete a tag, and return the deleted tag. Response: [Tag].
 * 
 * Note. Will also remove this tag from all attached resources.
 */
export interface DeleteTag {
	/** The id of the tag to delete. */
	id: string;
}

/** Rename a tag at id. Response: [Tag]. */
export interface RenameTag {
	/** The id of the tag to rename. */
	id: string;
	/** The new name of the tag. */
	name: string;
}

/**
 * Update the tags on a resource.
 * Response: [NoData]
 */
export interface UpdateTagsOnResource {
	target: ResourceTarget;
	/** Tag Ids */
	tags: string[];
}

/**
 * **Admin only.** Create a service user.
 * Response: [User].
 */
export interface CreateServiceUser {
	/** The username for the service user. */
	username: string;
	/** A description for the service user. */
	description: string;
}

/**
 * **Admin only.** Update a service user's description.
 * Response: [User].
 */
export interface UpdateServiceUserDescription {
	/** The service user's username */
	username: string;
	/** A new description for the service user. */
	description: string;
}

/** **Admin only.** Create a user group. Response: [UserGroup] */
export interface CreateUserGroup {
	/** The name to assign to the new UserGroup */
	name: string;
}

/** **Admin only.** Rename a user group. Response: [UserGroup] */
export interface RenameUserGroup {
	/** The id of the UserGroup */
	id: string;
	/** The new name for the UserGroup */
	name: string;
}

/** **Admin only.** Delete a user group. Response: [UserGroup] */
export interface DeleteUserGroup {
	/** The id of the UserGroup */
	id: string;
}

/** **Admin only.** Add a user to a user group. Response: [UserGroup] */
export interface AddUserToUserGroup {
	/** The name or id of UserGroup that user should be added to. */
	user_group: string;
	/** The id or username of the user to add */
	user: string;
}

/** **Admin only.** Remove a user from a user group. Response: [UserGroup] */
export interface RemoveUserFromUserGroup {
	/** The name or id of UserGroup that user should be removed from. */
	user_group: string;
	/** The id or username of the user to remove */
	user: string;
}

/**
 * **Admin only.** Completely override the user in the group.
 * Response: [UserGroup]
 */
export interface SetUsersInUserGroup {
	/** Id or name. */
	user_group: string;
	/** The user ids or usernames to hard set as the group's users. */
	users: string[];
}

/** **Admin only.** Create variable. Response: [Variable]. */
export interface CreateVariable {
	/** The name of the variable to create. */
	name: string;
	/** The initial value of the variable. defualt: "". */
	value?: string;
	/** The initial value of the description. default: "". */
	description?: string;
}

/** **Admin only.** Update variable. Response: [Variable]. */
export interface UpdateVariableValue {
	/** The name of the variable to update. */
	name: string;
	/** The value to set. */
	value: string;
}

/** **Admin only.** Update variable. Response: [Variable]. */
export interface UpdateVariableDescription {
	/** The name of the variable to update. */
	name: string;
	/** The description to set. */
	description: string;
}

/** **Admin only.** Delete a variable. Response: [Variable]. */
export interface DeleteVariable {
	name: string;
}

/** Configuration for a custom alerter endpoint. */
export interface CustomAlerterEndpoint {
	/** The http/s endpoint to send the POST to */
	url: string;
}

/** Configuration for a slack alerter. */
export interface SlackAlerterEndpoint {
	/** The slack app url */
	url: string;
}

/** Configuration for a cloud image registry, like account and organization. */
export interface CloudRegistryConfig {
	/** Specify an account to use with the cloud registry. */
	account?: string;
	/**
	 * Optional. Specify an organization to push the image under.
	 * Empty string means no organization.
	 */
	organization?: string;
}

/** Configuration for a monitor server builder. */
export interface ServerBuilderConfig {
	/** The server id of the builder */
	server_id: string;
}

/** Configuration for an AWS builder. */
export interface AwsBuilderConfig {
	/** The AWS region to create the instance in */
	region: string;
	/** The instance type to create for the build */
	instance_type: string;
	/** The size of the builder volume in gb */
	volume_gb: number;
	/**
	 * The port periphery will be running on.
	 * Default: `8120`
	 */
	port: number;
	/**
	 * The EC2 ami id to create.
	 * The ami should have the periphery client configured to start on startup,
	 * and should have the necessary github / dockerhub accounts configured.
	 */
	ami_id: string;
	/** The subnet id to create the instance in. */
	subnet_id: string;
	/** The key pair name to attach to the instance */
	key_pair_name: string;
	/**
	 * Whether to assign the instance a public IP address.
	 * Likely needed for the instance to be able to reach the open internet.
	 */
	assign_public_ip: boolean;
	/**
	 * Whether core should use the public IP address to communicate with periphery on the builder.
	 * If false, core will communicate with the instance using the private IP.
	 */
	use_public_ip: boolean;
	/**
	 * The security group ids to attach to the instance.
	 * This should include a security group to allow core inbound access to the periphery port.
	 */
	security_group_ids: string[];
	/** Which github accounts (usernames) are available on the AMI */
	github_accounts?: string[];
	/** Which dockerhub accounts (usernames) are available on the AMI */
	docker_accounts?: string[];
}

export interface CloneArgs {
	name: string;
	repo?: string;
	branch?: string;
	commit?: string;
	destination?: string;
	on_clone?: SystemCommand;
	on_pull?: SystemCommand;
	github_account?: string;
}

/** Info for the all system disks combined. */
export interface TotalDiskUsage {
	/** Used portion in GB */
	used_gb: number;
	/** Total size in GB */
	total_gb: number;
}

/** Summary of the health of the server. */
export interface ServerHealth {
	cpu: SeverityLevel;
	mem: SeverityLevel;
	disks: Record<string, SeverityLevel>;
}

export enum AwsVolumeType {
	Gp2 = "gp2",
	Gp3 = "gp3",
	Io1 = "io1",
	Io2 = "io2",
}

/**
 * For information on AWS volumes, see
 * `<https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html>`.
 */
export interface AwsVolume {
	/** The device name (for example, `/dev/sda1` or `xvdh`). */
	device_name: string;
	/** The size of the volume in GB */
	size_gb: number;
	/** The type of volume. Options: gp2, gp3, io1, io2. */
	volume_type: AwsVolumeType;
	/** The iops of the volume, or 0 for AWS default. */
	iops: number;
	/** The throughput of the volume, or 0 for AWS default. */
	throughput: number;
}

/** Aws EC2 instance config. */
export interface AwsServerTemplateConfig {
	/** The aws region to launch the server in, eg. us-east-1 */
	region: string;
	/** The instance type to launch, eg. c5.2xlarge */
	instance_type: string;
	/** Specify the ami id to use. Must be set up to start the periphery binary on startup. */
	ami_id: string;
	/** The subnet to assign to the instance. */
	subnet_id: string;
	/** The key pair name to give to the instance in case SSH access required. */
	key_pair_name: string;
	/**
	 * Assign a public ip to the instance. Depending on how your network is
	 * setup, this may be required for the instance to reach the public internet.
	 */
	assign_public_ip: boolean;
	/**
	 * Use the instances public ip as the address for the server.
	 * Could be used when build instances are created in another non-interconnected network to the core api.
	 */
	use_public_ip: boolean;
	/**
	 * The port periphery will be running on in AMI.
	 * Default: `8120`
	 */
	port: number;
	/** The user data to deploy the instance with. */
	user_data?: string;
	/** The security groups to give to the instance. */
	security_group_ids?: string[];
	/** Specify the EBS volumes to attach. */
	volumes: AwsVolume[];
}

export enum HetznerDatacenter {
	Nuremberg1Dc3 = "Nuremberg1Dc3",
	Helsinki1Dc2 = "Helsinki1Dc2",
	Falkenstein1Dc14 = "Falkenstein1Dc14",
	AshburnDc1 = "AshburnDc1",
	HillsboroDc1 = "HillsboroDc1",
}

export enum HetznerServerType {
	SharedIntel1Core2Ram20Disk = "SharedIntel1Core2Ram20Disk",
	SharedAmd2Core2Ram40Disk = "SharedAmd2Core2Ram40Disk",
	SharedArm2Core4Ram40Disk = "SharedArm2Core4Ram40Disk",
	SharedIntel2Core4Ram40Disk = "SharedIntel2Core4Ram40Disk",
	SharedAmd3Core4Ram80Disk = "SharedAmd3Core4Ram80Disk",
	SharedArm4Core8Ram80Disk = "SharedArm4Core8Ram80Disk",
	SharedIntel2Core8Ram80Disk = "SharedIntel2Core8Ram80Disk",
	SharedAmd4Core8Ram160Disk = "SharedAmd4Core8Ram160Disk",
	SharedArm8Core16Ram160Disk = "SharedArm8Core16Ram160Disk",
	SharedIntel4Core16Ram160Disk = "SharedIntel4Core16Ram160Disk",
	SharedAmd8Core16Ram240Disk = "SharedAmd8Core16Ram240Disk",
	SharedArm16Core32Ram320Disk = "SharedArm16Core32Ram320Disk",
	SharedIntel8Core32Ram240Disk = "SharedIntel8Core32Ram240Disk",
	SharedAmd16Core32Ram360Disk = "SharedAmd16Core32Ram360Disk",
	DedicatedAmd2Core8Ram80Disk = "DedicatedAmd2Core8Ram80Disk",
	DedicatedAmd4Core16Ram160Disk = "DedicatedAmd4Core16Ram160Disk",
	DedicatedAmd8Core32Ram240Disk = "DedicatedAmd8Core32Ram240Disk",
	DedicatedAmd16Core64Ram360Disk = "DedicatedAmd16Core64Ram360Disk",
	DedicatedAmd32Core128Ram600Disk = "DedicatedAmd32Core128Ram600Disk",
	DedicatedAmd48Core192Ram960Disk = "DedicatedAmd48Core192Ram960Disk",
}

export enum HetznerVolumeFormat {
	Xfs = "Xfs",
	Ext4 = "Ext4",
}

export interface HetznerVolumeSpecs {
	/** A name for the volume */
	name: string;
	/** Size of the volume in GB */
	size_gb: I64;
	/** The format for the volume */
	format?: HetznerVolumeFormat;
	/** Labels for the volume */
	labels?: Record<string, string>;
}

/** Hetzner server config. */
export interface HetznerServerTemplateConfig {
	/** ID or name of the Image the Server is created from */
	image?: string;
	/** ID or name of Datacenter to create Server in */
	datacenter?: HetznerDatacenter;
	/** Network IDs which should be attached to the Server private network interface at the creation time */
	private_network_ids?: I64[];
	/**
	 * ID of the Placement Group the server should be in,
	 * Or 0 to not use placement group.
	 */
	placement_group?: I64;
	/** Attach an IPv4 on the public NIC. If false, no IPv4 address will be attached. */
	enable_public_ipv4?: boolean;
	/** Attach an IPv6 on the public NIC. If false, no IPv6 address will be attached. */
	enable_public_ipv6?: boolean;
	/** The firewalls to attach to the instance */
	firewall_ids?: I64[];
	/** ID or name of the Server type this Server should be created with */
	server_type?: HetznerServerType;
	/** SSH key IDs ( integer ) or names ( string ) which should be injected into the Server at creation time */
	ssh_keys?: string[];
	/** Cloud-Init user data to use during Server creation. This field is limited to 32KiB. */
	user_data?: string;
	/** Connect to the instance using it's public ip. */
	use_public_ip?: boolean;
	/** Labels for the server */
	labels?: Record<string, string>;
	/** Specs for volumes to attach */
	volumes?: HetznerVolumeSpecs[];
	/**
	 * The port periphery will be running on in AMI.
	 * Default: `8120`
	 */
	port: number;
}

export interface SyncUpdate {
	/** Resources to create */
	to_create: number;
	/** Resources to update */
	to_update: number;
	/** Resources to delete */
	to_delete: number;
	/** A readable log of all the changes to be applied */
	log: string;
}

export interface PendingSyncUpdatesDataOk {
	/** Readable log of any pending server updates */
	server_updates?: SyncUpdate;
	/** Readable log of any pending deployment updates */
	deployment_updates?: SyncUpdate;
	/** Readable log of any pending build updates */
	build_updates?: SyncUpdate;
	/** Readable log of any pending repo updates */
	repo_updates?: SyncUpdate;
	/** Readable log of any pending procedure updates */
	procedure_updates?: SyncUpdate;
	/** Readable log of any pending alerter updates */
	alerter_updates?: SyncUpdate;
	/** Readable log of any pending builder updates */
	builder_updates?: SyncUpdate;
	/** Readable log of any pending server template updates */
	server_template_updates?: SyncUpdate;
	/** Readable log of any pending resource sync updates */
	resource_sync_updates?: SyncUpdate;
	/** Readable log of any pending variable updates */
	variable_updates?: SyncUpdate;
	/** Readable log of any pending user group updates */
	user_group_updates?: SyncUpdate;
}

export interface PendingSyncUpdatesDataErr {
	message: string;
}

export type AuthRequest = 
	| { type: "GetLoginOptions", params: GetLoginOptions }
	| { type: "CreateLocalUser", params: CreateLocalUser }
	| { type: "LoginLocalUser", params: LoginLocalUser }
	| { type: "ExchangeForJwt", params: ExchangeForJwt }
	| { type: "GetUser", params: GetUser };

export type ExecuteRequest = 
	| { type: "PruneContainers", params: PruneContainers }
	| { type: "PruneImages", params: PruneImages }
	| { type: "PruneNetworks", params: PruneNetworks }
	| { type: "Deploy", params: Deploy }
	| { type: "StartContainer", params: StartContainer }
	| { type: "StopContainer", params: StopContainer }
	| { type: "StopAllContainers", params: StopAllContainers }
	| { type: "RemoveContainer", params: RemoveContainer }
	| { type: "RunBuild", params: RunBuild }
	| { type: "CancelBuild", params: CancelBuild }
	| { type: "CloneRepo", params: CloneRepo }
	| { type: "PullRepo", params: PullRepo }
	| { type: "RunProcedure", params: RunProcedure }
	| { type: "LaunchServer", params: LaunchServer }
	| { type: "RunSync", params: RunSync };

export type ReadRequest = 
	| { type: "GetVersion", params: GetVersion }
	| { type: "GetCoreInfo", params: GetCoreInfo }
	| { type: "GetAvailableAwsEcrLabels", params: GetAvailableAwsEcrLabels }
	| { type: "GetUsername", params: GetUsername }
	| { type: "GetPermissionLevel", params: GetPermissionLevel }
	| { type: "FindUser", params: FindUser }
	| { type: "ListUsers", params: ListUsers }
	| { type: "ListApiKeys", params: ListApiKeys }
	| { type: "ListApiKeysForServiceUser", params: ListApiKeysForServiceUser }
	| { type: "ListPermissions", params: ListPermissions }
	| { type: "ListUserTargetPermissions", params: ListUserTargetPermissions }
	| { type: "GetUserGroup", params: GetUserGroup }
	| { type: "ListUserGroups", params: ListUserGroups }
	| { type: "FindResources", params: FindResources }
	| { type: "GetProceduresSummary", params: GetProceduresSummary }
	| { type: "GetProcedure", params: GetProcedure }
	| { type: "GetProcedureActionState", params: GetProcedureActionState }
	| { type: "ListProcedures", params: ListProcedures }
	| { type: "ListFullProcedures", params: ListFullProcedures }
	| { type: "GetServerTemplate", params: GetServerTemplate }
	| { type: "GetServerTemplatesSummary", params: GetServerTemplatesSummary }
	| { type: "ListServerTemplates", params: ListServerTemplates }
	| { type: "ListFullServerTemplates", params: ListFullServerTemplates }
	| { type: "GetServersSummary", params: GetServersSummary }
	| { type: "GetServer", params: GetServer }
	| { type: "GetServerState", params: GetServerState }
	| { type: "GetPeripheryVersion", params: GetPeripheryVersion }
	| { type: "GetDockerContainers", params: GetDockerContainers }
	| { type: "GetDockerImages", params: GetDockerImages }
	| { type: "GetDockerNetworks", params: GetDockerNetworks }
	| { type: "GetServerActionState", params: GetServerActionState }
	| { type: "GetHistoricalServerStats", params: GetHistoricalServerStats }
	| { type: "GetAvailableAccounts", params: GetAvailableAccounts }
	| { type: "GetAvailableSecrets", params: GetAvailableSecrets }
	| { type: "ListServers", params: ListServers }
	| { type: "ListFullServers", params: ListFullServers }
	| { type: "GetDeploymentsSummary", params: GetDeploymentsSummary }
	| { type: "GetDeployment", params: GetDeployment }
	| { type: "GetDeploymentContainer", params: GetDeploymentContainer }
	| { type: "GetDeploymentActionState", params: GetDeploymentActionState }
	| { type: "GetDeploymentStats", params: GetDeploymentStats }
	| { type: "GetLog", params: GetLog }
	| { type: "SearchLog", params: SearchLog }
	| { type: "ListDeployments", params: ListDeployments }
	| { type: "ListFullDeployments", params: ListFullDeployments }
	| { type: "ListCommonDeploymentExtraArgs", params: ListCommonDeploymentExtraArgs }
	| { type: "GetBuildsSummary", params: GetBuildsSummary }
	| { type: "GetBuild", params: GetBuild }
	| { type: "GetBuildActionState", params: GetBuildActionState }
	| { type: "GetBuildMonthlyStats", params: GetBuildMonthlyStats }
	| { type: "GetBuildVersions", params: GetBuildVersions }
	| { type: "GetBuildWebhookEnabled", params: GetBuildWebhookEnabled }
	| { type: "ListBuilds", params: ListBuilds }
	| { type: "ListFullBuilds", params: ListFullBuilds }
	| { type: "ListCommonBuildExtraArgs", params: ListCommonBuildExtraArgs }
	| { type: "ListGithubOrganizations", params: ListGithubOrganizations }
	| { type: "ListDockerOrganizations", params: ListDockerOrganizations }
	| { type: "GetReposSummary", params: GetReposSummary }
	| { type: "GetRepo", params: GetRepo }
	| { type: "GetRepoActionState", params: GetRepoActionState }
	| { type: "GetRepoWebhooksEnabled", params: GetRepoWebhooksEnabled }
	| { type: "ListRepos", params: ListRepos }
	| { type: "ListFullRepos", params: ListFullRepos }
	| { type: "GetResourceSyncsSummary", params: GetResourceSyncsSummary }
	| { type: "GetResourceSync", params: GetResourceSync }
	| { type: "GetResourceSyncActionState", params: GetResourceSyncActionState }
	| { type: "GetSyncWebhooksEnabled", params: GetSyncWebhooksEnabled }
	| { type: "ListResourceSyncs", params: ListResourceSyncs }
	| { type: "ListFullResourceSyncs", params: ListFullResourceSyncs }
	| { type: "GetBuildersSummary", params: GetBuildersSummary }
	| { type: "GetBuilder", params: GetBuilder }
	| { type: "GetBuilderAvailableAccounts", params: GetBuilderAvailableAccounts }
	| { type: "ListBuilders", params: ListBuilders }
	| { type: "ListFullBuilders", params: ListFullBuilders }
	| { type: "GetAlertersSummary", params: GetAlertersSummary }
	| { type: "GetAlerter", params: GetAlerter }
	| { type: "ListAlerters", params: ListAlerters }
	| { type: "ListFullAlerters", params: ListFullAlerters }
	| { type: "ExportAllResourcesToToml", params: ExportAllResourcesToToml }
	| { type: "ExportResourcesToToml", params: ExportResourcesToToml }
	| { type: "GetTag", params: GetTag }
	| { type: "ListTags", params: ListTags }
	| { type: "GetUpdate", params: GetUpdate }
	| { type: "ListUpdates", params: ListUpdates }
	| { type: "ListAlerts", params: ListAlerts }
	| { type: "GetAlert", params: GetAlert }
	| { type: "GetSystemInformation", params: GetSystemInformation }
	| { type: "GetSystemStats", params: GetSystemStats }
	| { type: "GetSystemProcesses", params: GetSystemProcesses }
	| { type: "GetVariable", params: GetVariable }
	| { type: "ListVariables", params: ListVariables };

export type UserRequest = 
	| { type: "PushRecentlyViewed", params: PushRecentlyViewed }
	| { type: "SetLastSeenUpdate", params: SetLastSeenUpdate }
	| { type: "CreateApiKey", params: CreateApiKey }
	| { type: "DeleteApiKey", params: DeleteApiKey };

export type WriteRequest = 
	| { type: "CreateServiceUser", params: CreateServiceUser }
	| { type: "UpdateServiceUserDescription", params: UpdateServiceUserDescription }
	| { type: "CreateApiKeyForServiceUser", params: CreateApiKeyForServiceUser }
	| { type: "DeleteApiKeyForServiceUser", params: DeleteApiKeyForServiceUser }
	| { type: "CreateUserGroup", params: CreateUserGroup }
	| { type: "RenameUserGroup", params: RenameUserGroup }
	| { type: "DeleteUserGroup", params: DeleteUserGroup }
	| { type: "AddUserToUserGroup", params: AddUserToUserGroup }
	| { type: "RemoveUserFromUserGroup", params: RemoveUserFromUserGroup }
	| { type: "SetUsersInUserGroup", params: SetUsersInUserGroup }
	| { type: "UpdateUserBasePermissions", params: UpdateUserBasePermissions }
	| { type: "UpdatePermissionOnResourceType", params: UpdatePermissionOnResourceType }
	| { type: "UpdatePermissionOnTarget", params: UpdatePermissionOnTarget }
	| { type: "UpdateDescription", params: UpdateDescription }
	| { type: "CreateServer", params: CreateServer }
	| { type: "DeleteServer", params: DeleteServer }
	| { type: "UpdateServer", params: UpdateServer }
	| { type: "RenameServer", params: RenameServer }
	| { type: "CreateNetwork", params: CreateNetwork }
	| { type: "DeleteNetwork", params: DeleteNetwork }
	| { type: "CreateDeployment", params: CreateDeployment }
	| { type: "CopyDeployment", params: CopyDeployment }
	| { type: "DeleteDeployment", params: DeleteDeployment }
	| { type: "UpdateDeployment", params: UpdateDeployment }
	| { type: "RenameDeployment", params: RenameDeployment }
	| { type: "CreateBuild", params: CreateBuild }
	| { type: "CopyBuild", params: CopyBuild }
	| { type: "DeleteBuild", params: DeleteBuild }
	| { type: "UpdateBuild", params: UpdateBuild }
	| { type: "CreateBuildWebhook", params: CreateBuildWebhook }
	| { type: "DeleteBuildWebhook", params: DeleteBuildWebhook }
	| { type: "CreateBuilder", params: CreateBuilder }
	| { type: "CopyBuilder", params: CopyBuilder }
	| { type: "DeleteBuilder", params: DeleteBuilder }
	| { type: "UpdateBuilder", params: UpdateBuilder }
	| { type: "CreateServerTemplate", params: CreateServerTemplate }
	| { type: "CopyServerTemplate", params: CopyServerTemplate }
	| { type: "DeleteServerTemplate", params: DeleteServerTemplate }
	| { type: "UpdateServerTemplate", params: UpdateServerTemplate }
	| { type: "CreateRepo", params: CreateRepo }
	| { type: "CopyRepo", params: CopyRepo }
	| { type: "DeleteRepo", params: DeleteRepo }
	| { type: "UpdateRepo", params: UpdateRepo }
	| { type: "CreateRepoWebhook", params: CreateRepoWebhook }
	| { type: "DeleteRepoWebhook", params: DeleteRepoWebhook }
	| { type: "CreateAlerter", params: CreateAlerter }
	| { type: "CopyAlerter", params: CopyAlerter }
	| { type: "DeleteAlerter", params: DeleteAlerter }
	| { type: "UpdateAlerter", params: UpdateAlerter }
	| { type: "CreateProcedure", params: CreateProcedure }
	| { type: "CopyProcedure", params: CopyProcedure }
	| { type: "DeleteProcedure", params: DeleteProcedure }
	| { type: "UpdateProcedure", params: UpdateProcedure }
	| { type: "CreateResourceSync", params: CreateResourceSync }
	| { type: "CopyResourceSync", params: CopyResourceSync }
	| { type: "DeleteResourceSync", params: DeleteResourceSync }
	| { type: "UpdateResourceSync", params: UpdateResourceSync }
	| { type: "RefreshResourceSyncPending", params: RefreshResourceSyncPending }
	| { type: "CreateSyncWebhook", params: CreateSyncWebhook }
	| { type: "DeleteSyncWebhook", params: DeleteSyncWebhook }
	| { type: "CreateTag", params: CreateTag }
	| { type: "DeleteTag", params: DeleteTag }
	| { type: "RenameTag", params: RenameTag }
	| { type: "UpdateTagsOnResource", params: UpdateTagsOnResource }
	| { type: "CreateVariable", params: CreateVariable }
	| { type: "UpdateVariableValue", params: UpdateVariableValue }
	| { type: "UpdateVariableDescription", params: UpdateVariableDescription }
	| { type: "DeleteVariable", params: DeleteVariable };

export type WsLoginMessage = 
	| { type: "Jwt", params: {
	jwt: string;
}}
	| { type: "ApiKeys", params: {
	key: string;
	secret: string;
}};

